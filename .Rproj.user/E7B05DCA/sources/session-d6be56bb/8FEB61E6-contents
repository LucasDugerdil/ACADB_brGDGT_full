#### Library ####
library(reshape2)
library(ggplot2)
library(patchwork)
library(randomForest)
library(dplyr)
library(palaeoSig)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
library(smotefamily)
library(tibble)
library(rgdal)
library(ggpmisc)
library(dismo) # BRT
set.seed(123)

#### Map ####
if(exists("ACA.bo") == F){
  Eurasia_map <- c("Mongolia", "Russia", "Spai n", "France", "Italy", "Greece", "Germany", "Finland", "Bhutan", "Bangladesh",
                   "Czech Republic", "Denmark", "Kosovo", "Vietnam", "Laos", "Japan", "Nepal", "India", "Myanmar",
                   "Latvia","Lithuania", "Estonia", "Belarus", "Romania", "Bulgaria", "Hungary", "Austria", "Croatia",
                   "Albania", "Serbia", "Slovenia", "Slovakia", "Bosnia", "Montenegro", "UK", "Ireland", "Moldova", "Macedonia",
                   "Norway", "Sweden", "Turkey", "Belgium", "Uzbekistan", "Tajikistan", "Syria", "Israel", "Jordan", "Pakistan",
                   "Kazakhstan","Turkmenistan", "Ukraine", "Poland", "Portugal", "Switzerland", "Kyrgyzstan", "Morocco",
                   "China", "Iran", "Armenia", "Georgia", "Afghanistan", "Iraq", "Azerbaijan")
  Eurasia_map <- map_data("world", region = Eurasia_map)
  
  Path.ACA.border = "Import/Map/Out_border_ACA.shp"
  ACA.bo = readOGR(Path.ACA.border)
  proj4string(ACA.bo) <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
  ACA.bo.proj = fortify(ACA.bo)}

#### Label settings ####
New.lab <- c("d13Corg" = "paste(delta^13,C[TOC])", "d13Ctot" = "paste(delta^13,C[tot])", "d15Ntot" = "paste(delta^15,N[tot])", "A: Core sections" = "MasterCore",
             "Corg.N_atom" = "C/N", "X.C_inorg_DeltaM" = "TIC", "wt..Ntot" = "wt~'%N'[tot]",
             "Fe/Al" = "Fe/Al", "Rb/Sr" = "Rb/Sr", "Ti/Al" = "Ti/Al", "K/Ca" = "K/Ca", "C14" = "paste(Dating^14,C)",
             "L" = "L\\*", "RABD660_670" = "RABD[660-670]", "Q7.4" = "Q[700/400]", "Chlo_a" = "Chlo[a]~(mg.g^-1)",
             "MAAT" = "MAAT (degree*C)", "MAF" = "MAF (degree*C)", "MAP" = "MAP~(mm.yr^-1)",  "MPCOQ" = "MPCOQ~(mm.yr^-1)", "Altitude" = "Altitude", "AI" = "AI", "Pspr" = "P[spring]~(mm.yr^-1)",
             "IIIa.IIa" = "Sigma(IIIa/IIa)", "Ib.Ia" = "Ib/Ia", "IR6_7Me" = "IR[6+7~Me]","IRp6_7Me" = "IRp[6+7~Me]", "GDGT0.Crenar" = "GDGT[0]/Crenar", "pCren" = "\'%\'[Cren]",
             # "Art_Ama/Poa" = "(Ar.+Amar.)/Poa.", "Poa/Ama" = "Poa./Amar.", "Ama/Art" = "Amar./Ar.", "Art/Ama+Art" = "Ar./(Amar.+Ar.)", "Art+Ama/Poa" = "(Ar.+Amar.)/Poa.", "Poa/Art" = "Poa./Ar.",
             "Art_Ama/Poa" = "over((Artemisia+Amaranth.), Poaceae)", "Poa/Ama" = "over(Poaceae, Amaranthaceae)", "Ama/Art" = "over(Amaranthaceae,Artemisia)", "Art/Ama+Art" = "over(Artemisia,(Amaranthaceae+Artemisia))", "Art+Ama/Poa" = "over((Artemisia+Amaranthaceae),Poaceae)", "Poa/Art" = "over(Poaceae,Artemisia)", "AP/NAP" = "over(Arboreal~Pollen, Non-Arboreal~Pollen)",
             "PC1" = "PC1[XRF]", "PC2" = "PC2[XRF]", "MS" = "MS~(10^-5~SI)", "Sus_mag" = "")

My.unit <- c("K/Ca" = NA, "Rb/Sr" = NA, "Rb/K" = NA, "Fe/Mn" = NA, "Ca/Mg" = NA, "Ca/Ti" = NA, "Al/Si" = NA, "Zr/Ti" = NA, "A: Core sections" = NA, "Inc/Coh" = NA, "Mn/Fe" = NA, "Coh/Inc" = NA,
             "Ti/Al" = NA, "Fe/Al" = NA, "Br/Ti" = NA, "Sr/Ca" = NA, "S/Fe" = NA, "Si/Ti" = NA, "S/Ti" = NA, "K/Ti" = NA, "Mg/Ca" = NA, "Sr/Ti" = NA, "Coh" = NA, "Inc" = NA, "C14" = NA,
             "Al" = NA, "Si" = NA, "K" = NA, "Ti" = NA, "S" = NA, "Mn" = NA, "Fe" = NA, "Ca" = NA, "Zr" = NA, "Zn" = NA, "Rb" = NA, "Sr" = NA, "Br" = NA, "Cu" = NA, "Pb" = NA, "Ar" = NA, "P" = NA,
             "PC1" = NA, "PC2" = NA, "BIT" = NA, "IIIa.IIa" = NA, "Q7.4" = NA, "RABD660_670" = NA, "CONISS" = NA, "Sus_mag" = "10e-5 SI", "Chlo_a" = NA, "Density" = NA, "MS" = NA, 
             "Ib.Ia" = NA, "pCren" = NA, "IR6_7Me" = NA, "IRp6_7Me" = NA, "GDGT0.Crenar" = NA, "IR" = NA, "CI" = NA, " " = NA,
             "MAAT" = "°C", "MAF" = "°C", "MAP" = NA, "MPCOQ" = NA, "Altitude" = "m a.s.l.", "AI" = NA, "Pspr" = NA, "Units" = NA,
             "Poa/Art" = NA, "Poa/Ama" = NA, "Ama/Art" = NA, "Art/Ama+Art" = NA, "AP/NAP" = NA, "Art_Ama/Poa" = NA,
             "Corg.N_atom" = NA, "d13Corg" = "%", "d15Ntot" = "%", "d13Ctot" = "%")

#### Functions  ####

# This function plot the boxplot for each br-GDGT fractional abundance
# If you add Mtype, it make the groups for moss, soils and sediment...
# Graph présent chez Ding et al. 2015, Hopmans et al. 2004
# Si ajout iso.GDGT, Hopmans et al. 2004 
GDGT.histo.plot.surf.core <- function(Mcore, Msurf, Mtype, Select.type, Show.Plotly, Reorder.group, Global.box = F, Annot.size = 6,
                                      Keep.br, Leg.nb.lines, Leg.iso = F, Box.linewidth = .5, Leg.size = 13,
                                      Remove.8Me, Remove.7Me, Color.choice, Iso.GDGT, Leg.pos, Return.plot = F, Boxplot.title = NULL, Leg.box = F,
                                      Zoom1.comp = NULL, Zoom2.comp = NULL, Zoom1.Ymax, Zoom2.Ymax, Insert1.loc = NULL, Insert2.loc = NULL,
                                      Name.untype, Ymax, Save.path, W, H, Dot.pop, Overlap.OK){
  #### Initialization values ####
  if(missing(Mtype)){Mtype = NULL}
  if(missing(Msurf)){Msurf = NULL}
  if(missing(Mcore)){Mcore = NULL}
  if(missing(Reorder.group)){Reorder.group = NULL}
  if(missing(Show.Plotly)){Show.Plotly = F}
  if(missing(Save.path)){Save.path = NULL}
  if(missing(W)){W = NULL}
  if(missing(H)){H = NULL}
  if(missing(Keep.br)){Keep.br = NULL}
  if(missing(Leg.nb.lines)){Leg.nb.lines = NULL}
  if(missing(Dot.pop)){Dot.pop = NULL}
  if(missing(Overlap.OK)){Overlap.OK = F}
  if(missing(Name.untype)){Name.untype = "Other"}
  if(missing(Select.type)){Select.type = "Sample.type"}
  if(missing(Color.choice)){Color.choice = NULL}
  if(missing(Remove.8Me)){Remove.8Me = F}
  if(missing(Remove.7Me)){Remove.7Me = F}
  if(missing(Iso.GDGT)){Iso.GDGT = F}
  if(missing(Leg.pos)){Leg.pos = c(0.31,.86)}
  
  #### Extract br-GDGT ####
  MBRcore <- Mcore[,grep("^f.I", colnames(Mcore))]
  MBRsurf <- Msurf[,grep("^f.I", colnames(Msurf))]
  
  #### Remove 8 Me ####
  if(Remove.8Me == T){
    MBRcore <- MBRcore[,!grepl("_8Me", colnames(MBRcore))]
    MBRsurf <- MBRsurf[,!grepl("_8Me", colnames(MBRsurf))]
  }
  
  #### Remove 7 Me ####
  if(Remove.7Me == T){
    MBRcore <- MBRcore[,!grepl("_7Me", colnames(MBRcore))]
    MBRsurf <- MBRsurf[,!grepl("_7Me", colnames(MBRsurf))]
  }
  
  if(is.null(MBRsurf) == F){MBRsurf <- MBRsurf[setdiff(names(MBRsurf), names(MBRsurf)[which(colSums(MBRsurf) == 0)])]}
  if(is.null(MBRcore) == F){MBRcore <- MBRcore[setdiff(names(MBRcore), names(MBRcore)[which(colSums(MBRcore) == 0)])]}
  
  #### Test if the names are egual ####
  if(is.null(MBRcore) == F & is.null(MBRsurf) == F){
    '%nin%' <- Negate('%in%')
    test1 <- length(names(MBRcore)[names(MBRcore) %nin% names(MBRsurf)])
    test2 <- length(names(MBRsurf)[names(MBRsurf) %nin% names(MBRsurf)])
    
    if(test1 > 0 & test2 > 0){
      print("Names are different.")
      break
    }
    if(test1 == 0 & test2 == 0){
      print("Let's go !")
      Mplot <- rbind(MBRcore, MBRsurf)   
    }
    else{print("Some molecules are missing !")
      print(setdiff(names(MBRsurf), names(MBRcore)))
      print(setdiff(names(MBRcore), names(MBRsurf)))
    }
  }
  else{
    if(is.null(MBRcore) == F){Mplot = MBRcore[,grep("^f.I", colnames(MBRcore))]}
    if(is.null(MBRsurf) == F){Mplot = MBRsurf[,grep("^f.I", colnames(MBRsurf))]}
  }
  
  #### Extract iso-GDGT ####
  if(Iso.GDGT == T){
    #### Recuperation des iso GDGT dans M tot ####
    if(is.null(Mcore) == F){
      Mcore.iso <- cbind(Mcore[,grep("^GDGT", colnames(Mcore))], Crenarch = Mcore$Crenarch, Crenarch.p = Mcore$Crenarch.p)
      if(is.null(Mcore.iso$GDGT0.Crenar) == F){Mcore.iso <- subset(Mcore.iso, select = -c(GDGT0.Crenar))} 
      Mcore.iso <- Mcore.iso/rowSums(Mcore.iso)*100
      
      #### Stats iso-GDGTs ####
    }
    
    if(is.null(Msurf) == F){
      Msurf.iso <- cbind(Msurf[,grep("^GDGT", colnames(Msurf))], Crenarch = Msurf$Crenarch, Crenarch.p = Msurf$Crenarch.p)
      if(is.null(Msurf.iso$GDGT0.Crenar) == F){Msurf.iso <- Msurf.iso[!grepl("GDGT0.Crenar", names(Msurf.iso))]}
      Msurf.iso <- Msurf.iso/rowSums(Msurf.iso)*100
    }
    
    if(is.null(Mcore) == F & is.null(Msurf) == F){
      Ymax.iso = max(max(Mcore.iso), max(Msurf.iso))
      L.iso = rbind(Msurf.iso, Mcore.iso)}
    if(is.null(Mcore) == T & is.null(Msurf) == F){
      Ymax.iso = max(Msurf.iso)
      L.iso = Msurf.iso}
    if(is.null(Mcore) == F & is.null(Msurf) == T){
      Ymax.iso = max(Mcore.iso)
      L.iso = Mcore.iso}
    #### Mise en forme des labels des axes ####
    if(is.null(Mtype) == F){
      Mtype <- Mtype[Select.type]
      names(Mtype) <- "Sample.type"
      A.iso <- merge(L.iso, Mtype, all.x = T, by = 0, sort = F)
      row.names(A.iso)<- A.iso$Row.names
      A.iso <- A.iso[,-1]
      levels(A.iso$Sample.type)[length(levels(A.iso$Sample.type)) + 1] <- Name.untype
      A.iso$Sample.type[is.na(A.iso$Sample.type)] <- Name.untype
    }
    else{ 
      A.iso <- L.iso 
      A.iso["Sample.type"]="Samples"}
    
    
    
    Model.lab <- gsub("GDGT", "GDGT-", names(A.iso))
    # Model.lab <- gsub("0", "0]", Model.lab)
    # Model.lab <- gsub("1", "1]", Model.lab)
    # Model.lab <- gsub("2", "2]", Model.lab)
    # Model.lab <- gsub("3", "3]", Model.lab)
    # Model.lab <- gsub("4", "4]", Model.lab)
    #Model.lab <- Model.lab[-1]                  # on enleve Row.names()
    Model.lab <- Model.lab[-length(Model.lab)]     # on enleve Samples.type
    Model.lab <- Model.lab[-length(Model.lab)]     # on enleve Crenarch.p et plus tard on rajoute Crenarch'
    
    #### If little pop to dot activated ####
    if(is.null(Dot.pop) == F){ # Echantillons choisis comme points
      Little.pop.iso <- A.iso[A.iso$Sample.type %in% Dot.pop,]
      for(i in 1:length(Dot.pop)){
        New.lab.iso <- unique(A.iso$Sample.type)[grepl(Dot.pop[i], unique(A.iso$Sample.type))]
        Little.pop.iso$Sample.type <- gsub(Dot.pop[i], New.lab.iso, Little.pop.iso$Sample.type)
        if(Overlap.OK == T){A.iso[A.iso$Sample.type %in% New.lab.iso, names(A.iso[,-length(names(A.iso))])] <- 100}}
      
      Not.in.dot.iso <- setdiff(unique(as.character(A.iso$Sample.type)), Dot.pop)
      New.row.0.iso <- data.frame(Sample.type = Not.in.dot.iso)
      Little.pop.iso <- rbind.fill(Little.pop.iso, New.row.0.iso)
      Little.pop.iso[is.na(Little.pop.iso)] <- 100
      A.little.iso <- melt(Little.pop.iso, id ='Sample.type')
      Add.points.size.lim.iso <- geom_dotplot(data = A.little.iso, aes(x=variable, y=value, fill=Sample.type),
                                              binaxis='y', stackdir='center', 
                                              position = position_dodge(.85),
                                              show.legend = FALSE,
                                              binwidth = 1)
      A.iso$Sample.type <- as.character(A.iso$Sample.type)
      A.iso <- melt(A.iso, id ='Sample.type')}
    
    else{                   # Pas échatillon comme points
      Add.points.size.lim.iso <- NULL
      A.iso$Sample.type <- as.character(A.iso$Sample.type)
      A.iso <- melt(A.iso, id ='Sample.type')
    }
  }
  else{A.iso = NULL}
  
  
  #### Label type ####
  Mplot <- 100*Mplot
  AZER <- gsub("f.", "", names(Mplot))
  AZER <- gsub("_5Me", "", AZER)
  AZER <- gsub("_6Me", "\\'", AZER)
  AZER <- gsub("_7Me", "\\''", AZER)
  AZER <- gsub("_8Me", "\\'''", AZER)
  names(Mplot)  <- AZER
  if(missing(Ymax)){Ymax = max(Mplot)}
  
  #### Merging datas ####
  if(is.null(Mtype) == F){
    if(Iso.GDGT == F){
      Mtype <- Mtype[Select.type]
      names(Mtype) <- "Sample.type"
    }
    A <- merge(Mplot, Mtype, all.x = T, by = 0, sort = F)
    row.names(A)<- A$Row.names
    A <- A[,-1]
    levels(A$Sample.type)[length(levels(A$Sample.type)) + 1] <- Name.untype
    A[is.na(A)] <- Name.untype
  }
  
  else{ 
    A = Mplot 
    A["Sample.type"]="Samples"}
  
  #### Counting n of each samples ####
  M.type <- as.character(A$Sample.type)
  N.type <- unique(M.type)
  NT <- sapply(N.type, function(x) length(M.type[M.type == x]))
  A.save <- A
  for(i in 1:length(NT)){A$Sample.type <- gsub(names(NT)[i], paste(names(NT)[i], ", n = ", NT[i], sep = ""), A$Sample.type)}
  A$Sample.type <- as.factor(A$Sample.type)
  
  if(Iso.GDGT == T & Leg.iso == T){
    for(i in 1:length(NT)){A.iso$Sample.type <- gsub(names(NT)[i], paste(names(NT)[i], ", n = ", NT[i], sep = ""), A.iso$Sample.type)}
    A.iso$Sample.type <- as.factor(A.iso$Sample.type)
  }
  
  #### Little sample size br-GDGT ####
  if(is.null(Dot.pop) == F){ # Echantillons choisis comme points
    Little.pop <- A.save[A.save$Sample.type %in% Dot.pop,]
    for(i in 1:length(Dot.pop)){
      New.lab <- unique(A$Sample.type)[grepl(Dot.pop[i], unique(A$Sample.type))]
      Little.pop$Sample.type <- gsub(Dot.pop[i], New.lab, Little.pop$Sample.type)
      if(Overlap.OK == T){A[A$Sample.type %in% New.lab, names(A[,-length(names(A))])] <- 100}}
    
    Not.in.dot <- setdiff(levels(A$Sample.type), Dot.pop)
    New.row.0 <- data.frame(Sample.type = Not.in.dot)
    Little.pop <- rbind.fill(Little.pop, New.row.0)
    Little.pop[is.na(Little.pop)] <- 100
    
    B.little <- melt(Little.pop, id ='Sample.type')
    
    if(is.null(Keep.br) == F){
      Keep.br.little <- levels(B.little$variable)[Keep.br] 
      B.little <- B.little[which(B.little$variable %in% Keep.br.little),]}
    
    Add.points.size.lim <- geom_dotplot(data = B.little, aes(x=variable, y=value, fill=Sample.type),
                                        binaxis='y', stackdir='center', 
                                        position = position_dodge(.85),
                                        show.legend = FALSE,
                                        binwidth = .5)
    B <- melt(A, id ='Sample.type')
  }
  
  else{                   # Pas échatillon comme points
    Add.points.size.lim <- NULL
    B <- melt(A, id ='Sample.type')
  }
  
  #### Color settings ####
  if(is.null(Color.choice) == T){
    if(length(NT) == 1){Color.vec <- c("grey")}
    if(length(NT) == 2){Color.vec <- c("#74D43B", "#1EAEAE")}
    if(length(NT) == 3){Color.vec <- c("#74D43B", "#1EAEAE", "#F3C643")}
    if(length(NT) == 4){Color.vec <- c("#74D43B", "#1EAEAE", "#F3C643", "grey")}
    if(length(NT) == 5){Color.vec <- c("#74D43B", "#1EAEAE", "grey", "#F3C643",  "darkorange")}
    if(length(NT) == 6){Color.vec <- c("#74D43B", "#1EAEAE", "grey", "#F3C643",  "darkorange", "indianred2")}
    if(length(NT) == 7){Color.vec <- c("#74D43B", "#1EAEAE", "grey", "#F3C643",  "darkorange", "indianred2", "darksalmon")}
    if(length(NT) == 8){Color.vec <- c("#74D43B", "#1EAEAE", "grey", "#F3C643",  "darkorange", "indianred2", "darksalmon", "darkred")}
    if(length(NT) > 8){Color.vec <- colorRampPalette(rev(brewer.pal(11, "Spectral")))(NT)}}
  else{Color.vec <- Color.choice}
  
  #### Other graphical settings ####
  if(Global.box == T){My_border <- element_rect(fill = NA)}
  else{My_border <- element_blank()}
  
  if(is.null(Boxplot.title) == F){My_title <- ggtitle(Boxplot.title)}
  else{My_title <- NULL}
  
  if(Leg.box == T){My_legbox <- element_rect(fill = "white", color = "grey")}
  else{My_legbox <- NULL}
  
  #### Change order of boxplot ####
  if(is.null(Reorder.group) == F){
    if(Iso.GDGT == T){
      Old.order.name <- unique(A.iso$Sample.type)[order(unique(A.iso$Sample.type))]
      A.iso$Sample.type <- factor(A.iso$Sample.type, levels = Old.order.name[Reorder.group], ordered = T)}
    
    B$Sample.type <- factor(B$Sample.type, levels = levels(B$Sample.type)[Reorder.group], ordered = T)
    Color.vec <- Color.vec[Reorder.group]}
  
  #### brGDGTs last settings ####
  if(Iso.GDGT == F){A.lab = ylab("Fractional Abundance (%)")}
  if(Iso.GDGT == T){A.lab = ylab("")}
  
  if(is.null(Keep.br) == F){
    Keep.br <- levels(B$variable)[Keep.br] 
    B <- B[which(B$variable %in% Keep.br),]}
  
  if(is.null(Leg.nb.lines) == F){
    Leg.guide <- guides(fill = guide_legend(nrow = Leg.nb.lines))
  }
  else{Leg.guide <- NULL}  
  
  if(Iso.GDGT == T & Leg.iso == T){
    Leg.pos.iso <- Leg.pos
    Leg.pos <- "none"
  }
  else{Leg.pos.iso <- "none"}
  
  #### Add ligne en tirets ####
  Xligne <- c(
    max(grep("III", levels(B$variable)))+0.5,
    max(grep("II", levels(B$variable)))+0.5)
  
  Xtext <- c(Xligne[1]/2-0.25, (Xligne[1]+Xligne[2])/2-0.25, (Xligne[2]+nlevels(B$variable))/2)
  My_lab <- c("Hexa.", "Penta.", "Tetra.")
  
  #### Insert LR ####
  get_inset <- function(B, Zoom1.Ymax, My_annot){
    pinsert <- ggplot(B, aes(x=variable, y=value, fill = Sample.type)) + 
      coord_cartesian(ylim = c(0, Zoom1.Ymax)) +
      geom_boxplot(outlier.shape = NA, position = position_dodge(.85), linewidth = Box.linewidth) +
      Add.points.size.lim + Leg.guide +
      scale_fill_manual(name = "Sample type", values = Color.vec
                        , labels = c("0" = "Foo", "1" = "Bar"))+
      annotate("text", x = 0.8, y = Zoom1.Ymax - 0.1*Zoom1.Ymax, label = My_annot, size = 5, fontface = 2)+
      theme(legend.position = "none", panel.background = element_blank(),
            legend.key = element_blank(), legend.background = element_blank(),
            axis.title = element_blank(),
            axis.text = element_text(size = 12), panel.grid = element_blank(),
            plot.margin = unit(x = c(1, 2, 2, 0),units="mm"), # Bas / Droite / Haut / Gauche
            axis.line = element_blank(),
            legend.text = element_text(size = 13),
            panel.border = element_rect(fill = NA),
            legend.title = element_text(size = 14),
            plot.background = element_blank())+
      A.lab
    return(pinsert)
  }
  
  if(is.null(Zoom1.comp) == F){
    B.insert <- B[which(B$variable %in% levels(B$variable)[Zoom1.comp]),]
    if(missing(Zoom1.Ymax)){Zoom1.Ymax = max(B.insert)}
    if(missing(Insert1.loc)){Insert1.loc = c(3, Xligne[1]-0.25, 10, 40)}
    
    My_insert1 <- get_inset(B.insert, Zoom1.Ymax, "B1")
    My_insert1 <- annotation_custom(ggplotGrob(My_insert1), xmin = Insert1.loc[1], xmax = Insert1.loc[2], ymin = Insert1.loc[3], ymax = Insert1.loc[4])
    Box1 <- geom_rect(xmin = min(Zoom1.comp)-0.5, xmax = Insert1.loc[2], ymin = -1, ymax = Zoom1.Ymax*2, fill = NA,
                      alpha = 1, color = "grey30", linewidth = .3, linetype = 2)
  }
  else{My_insert1 = NULL; Box1 <- NULL}
  
  if(is.null(Zoom2.comp) == F){
    B.insert <- B[which(B$variable %in% levels(B$variable)[Zoom2.comp]),]
    if(missing(Zoom2.Ymax)){Zoom2.Ymax = max(B.insert)}
    if(missing(Insert2.loc)){Insert2.loc = c(11, Xligne[2]-0.25, 10, 40)}
    
    My_insert2 <- get_inset(B.insert, Zoom2.Ymax, "B2")
    My_insert2 <- annotation_custom(ggplotGrob(My_insert2), xmin = Insert2.loc[1], xmax = Insert2.loc[2], ymin = Insert2.loc[3], ymax = Insert2.loc[4])
    Box2 <- geom_rect(xmin = min(Zoom2.comp)-0.5, xmax = Insert2.loc[2], ymin = -1, ymax = Zoom2.Ymax*2, fill = NA,
                      alpha = 1, color = "grey30", linewidth = .3, linetype = 2)
  }
  else{My_insert2 = NULL; Box2 <- NULL}
  
  #### Plot brGDGT ####
  p2 <- ggplot(B, aes(x=variable, y=value, fill = Sample.type)) + 
    coord_cartesian(ylim = c(0, Ymax)) + 
    xlab("brGDGTs") +
    geom_boxplot(outlier.shape = NA, position = position_dodge(.85), linewidth = Box.linewidth) +
    Add.points.size.lim + Leg.guide + My_title +
    geom_vline(xintercept = c(Xligne), lty="dotted")+
    annotate("text", x = Xtext, y = Ymax, label = My_lab, size = Annot.size, hjust = 0.25)+
    scale_fill_manual(name = "Sample type", values = Color.vec
                      , labels = c("0" = "Foo", "1" = "Bar"))+
    theme(legend.position = Leg.pos, panel.background = element_blank(),
          legend.key = element_blank(), legend.background = My_legbox,
          axis.title = element_text(size = 14), panel.border = My_border,
          axis.text = element_text(size = 12), panel.grid = element_blank(),
          plot.margin = unit(x = c(1, 2, 2, 0),units="mm"), # Bas / Droite / Haut / Gauche
          axis.line = element_line(colour = "black"), legend.text = element_text(size = Leg.size),
          legend.title = element_text(size = Leg.size*1.3),
          plot.background = element_blank())+
    A.lab + My_insert1 + My_insert2 + Box1 + Box2
  
  plot_build <- ggplot_build(p2)
  boxplot_stats <- plot_build$data[[1]]
  boxplot_stats <- round(boxplot_stats[c(13,3:5)], digits = 0)
  
  #### Plot isoGDGT ####
  if(Iso.GDGT == T){
    p1 <- ggplot(A.iso, aes(x=variable, y=value, fill=Sample.type)) + 
      coord_cartesian(ylim = c(0, Ymax.iso)) + 
      ylab("Fractional Abundance (%)")+
      xlab("isoGDGTs") +
      geom_boxplot(outlier.shape = NA, position = position_dodge(.85), linewidth = Box.linewidth) +
      scale_x_discrete(labels = c(parse(text = Model.lab), "Crenach\'"))+
      Add.points.size.lim.iso +
      scale_fill_manual(name = "Sample type", values = Color.vec
                        , labels = c("0" = "Foo", "1" = "Bar"))+
      theme(axis.text.x = element_text(angle = 25, hjust = 1),
            legend.position = Leg.pos.iso, panel.grid = element_blank(),
            panel.background = element_blank(), legend.background = element_blank(),
            axis.title = element_text(size = 14),
            axis.text = element_text(size = 12),
            axis.line = element_line(colour = "black"),
            legend.text = element_text(size = 13),
            legend.title = element_text(size = 14),
            plot.margin = unit(x = c(0, 0, 0, 0),units="mm"), 
            plot.background = element_blank()
      )
    
    # p3 <- plot_grid(p1, p2, ncol = 2, axis="tb", align = "h", rel_widths = c(3/10, 7/10), labels = c("A","B"), label_size = 18, label_x = -0.01) # 2 graphs
    p3 <- p1 + p2 + plot_layout(ncol = 2, widths = c(3/10, 7/10)) + plot_annotation(tag_levels = 'A') &
      theme(plot.tag = element_text(size = 18, face = "bold", hjust = 0.5, vjust = -3.5), strip.background = element_blank(),
            plot.background = element_blank(), plot.margin = unit(x = c(0, 0, 0, 0),units="mm"))
    
  }
  
  #### Save html ####
  if(Show.Plotly == T){
    library(plotly)
    library(htmlwidgets)
    Save.plot.html <- gsub("pdf", "html", Save.path)
    Keep.name <- gsub(".*\\/", "", Save.plot.html)
    Path.root <- paste(gsub(Keep.name, "", Save.plot.html), "HTML_files/", sep = "")
    if(file.exists(Path.root) == F){dir.create(Path.root)}
    Save.plot.html <- paste(Path.root, Keep.name, sep = "")
    p1_ly <- ggplotly(p2)
    p1_ly <- p1_ly %>% layout(boxmode = "group", boxpoints = F, legend = list(font = list(size = 12)))
    options(warn = - 1) 
    saveWidget(p1_ly, file = Save.plot.html)
  }
  #### Save plots ####
  if(is.null(Save.path) == F){
    if(is.null(W) == F & is.null(H) == F){
      ggsave(Save.path, width = W*0.026458333, height = H*0.026458333, units = "cm")}
    else{ggsave(Save.path)}}
  else(
    if(Iso.GDGT == T){return(p3)}
    else{return(p2)})
  # if(is.null(p2) == F){View(ggplot_build(p1)$data[[1]])}
  
  if(Return.plot == T){
    if(Iso.GDGT == T){return(p3)}
    else{return(p2)}
  }
}

FT.quantif <- function(MPol, MClim, Model, Min.NB = NULL, External.CV = F, External.K.fold = 10, Internal.K.fold = 10, Display.final.set = F, Transformation = F,
                       RF.mtry = 2, RF.ntree = 500, Parallelize = F, Parallelize.ncores = NULL, BRT.remove.constante.var = T, BRT.settings = NULL,
                       BRT.max_trees = 7000, BRT.learning_rate = 0.025, BRT.tree_complexity = 4, BRT.bag_fraction = 0.75, BRT.package = "dismo", BRT.minobs = 10, BRT.ntree.recalcul = F,
                       Save.path, Save.RDS = F, Verbose = F, Mcoord, Nb.arg = NULL){
  #### Settings ####
  tictoc::tic(paste("FT.quantif run for the", Model, "on", substitute(MPol), "dataset."))
  
  if(missing(Model)){Model = "WAPLS"; print("Default model choice : WAPLS")}
  Save.tab = T
  Autocorrel.check = T
  if(missing(Save.path)){Save.tab = F}
  if(missing(Mcoord)){Autocorrel.check = F}
  tableWAPLS <- vector("list", length(MClim))
  Tab.impor.taxa <- vector("list", length(MClim))
  Tab.result <- list()
  Best.param <- list()
  Tab.KFCV <- list()
  
  #### Parallelize settings ####
  if(Parallelize == T){
    library(doParallel)
    library(foreach)
    library(doRNG)
    
    if(is.null(Parallelize.ncores) == T){cl <- makeCluster(parallel::detectCores() - 1)}
    else{n.cores <- min(Parallelize.ncores, detectCores()-1); cl <- makeCluster(n.cores)}
    
    registerDoParallel(cl)
  }
  
  #### Function single run ####
  FT.single_run <- function(Model, Min.NB, Nb.arg, i, MClim, MPol, tableWAPLS, External.CV, RF.mtry, External.K.fold, Verbose, Tab.impor.taxa, BRT.settings,
                            BRT.max_trees, BRT.tree_complexity, BRT.learning_rate, BRT.bag_fraction, BRT.package, BRT.minobs, BRT.ntree.recalcul, Internal.K.fold, Autocorrel.check, 
                            Mcoord, RF.ntree, Tab.result, Best.param, BRT.remove.constante.var, Transformation){
    #### WAPLS ####
    if(Model == "WAPLS"){
      if(is.null(Min.NB) == T){Min.NB = 2}
      if(is.null(Nb.arg) == T){Nb.arg = 5}
      print(paste(round((i/length(MClim))*100), "% done for the ", names(MClim)[i], sep = ""))
      if(Transformation == T){MPol <- sqrt(MPol)}
      Fit.i = WAPLS(MPol, MClim[[i]], npls = Nb.arg, lean=F)
      Fit.CV = crossval(Fit.i, k = Fit.i$k, cv.method="bootstrap", verbose=F, ngroups=5, nboot=500, h.cutoff=0, h.dist=NULL)
      tableWAPLS[[i]] <- Fit.i
    }
    
    #### MAT ####
    if(Model == "MAT"){
      if(is.null(Min.NB) == T){Min.NB = 4}
      if(is.null(Nb.arg) == T){Nb.arg = 10}
      print(paste(round((i/length(MClim))*100), "% done for the ", names(MClim)[i], sep = ""))
      if(Transformation == T){MPol <- sqrt(MPol)}
      Fit.i = MAT(MPol, MClim[[i]], k = Nb.arg, lean=F)
      
      Fit.CV = crossval(Fit.i, k = Fit.i$k, cv.method="bootstrap", verbose=F, ngroups=5, nboot=500, h.cutoff=0, h.dist=NULL)
      tableWAPLS[[i]] <- Fit.i
    }
    
    #### Random Forest (RF) ####
    if(Model == "RF"){
      print(paste(round((i/length(MClim))*100), "% done for the ", names(MClim)[i], sep = ""))
      DB <- cbind(param.climat = MClim[[i]], MPol)

      if(External.CV == T){
        library(caret)
        rf_grid <- expand.grid(mtry = RF.mtry)
        repeat_cv <- trainControl(method = 'cv', number = External.K.fold, verboseIter = Verbose)
        Fit.CV <- caret::train(param.climat ~., data = DB, method = 'rf', trControl = repeat_cv, tuneGrid = rf_grid, ntree = RF.ntree)
        Fit.i <- Fit.CV$finalModel
      }
      else{
        if(length(RF.mtry)> 1){
          RF.mtry <- RF.mtry[length(RF.mtry)]
          print(paste("**** Mtry settled to ", RF.mtry, ". ****", sep = ""))
        }
        Fit.i <- randomForest(param.climat ~., data = DB, ntree = RF.ntree, mtry = RF.mtry, na.action = na.roughfix, importance = F)
      }
      
      # Je pense qu'il faut plus utiliser rfcv(), mea culpa
      # Fit.CV <- rfcv(MPol, MClim[[i]], cv.fold = 10) # sert plutôt à estimer le nombre de variables à garder, mais j'ai pas trop compris comment ca fonctionne.
      # Best.CV.error <-  names(Fit.CV$error.cv)[match(min(Fit.CV$error.cv), Fit.CV$error.cv)]
      # Residual.RF <- Fit.CV$predicted[[Best.CV.error]]
      Residual.RF <- Fit.i$predicted
      Residual.RF <- Residual.RF - MClim[[i]]
      influence <- round(Fit.i$importance/sum(Fit.i$importance, na.rm = T)*100, digits = 1)
      tableWAPLS[[i]] <- Fit.i
    }
    
    #### Boosted Regression Tree (BRT) ####
    if(Model == "BRT"){
      #### Settings ####
      print(paste(round((i/length(MClim))*100), "% done for the ", names(MClim)[i], sep = ""))
      
      if(BRT.remove.constante.var == T){
        nzv <- caret::nearZeroVar(MPol, saveMetrics = TRUE)  # En faite, c'est plutôt les variables qui sont constantes
        MPol <- MPol[, nzv$nzv == F]
      }
      
      DB <- cbind(param.climat = MClim[[i]], MPol)
      
      #### External k-fold CV ####
      if(External.CV == T){
        if(length(BRT.max_trees) == 1){BRT.ntree <- seq(50, BRT.max_trees, 50)}
        else{BRT.ntree <- BRT.max_trees}
        
        repeat_cv <- trainControl(method = 'cv', number = External.K.fold, verboseIter = Verbose)
        tune_grid <- expand.grid(n.trees = BRT.ntree, interaction.depth = BRT.tree_complexity, shrinkage = BRT.learning_rate, n.minobsinnode = BRT.minobs)
        Fit.CV <- caret::train(param.climat ~., data = DB, tuneGrid = tune_grid, method = 'gbm', trControl = repeat_cv, verbose = Verbose, bag.fraction = BRT.bag_fraction)
        
        Fit.i <- Fit.CV$finalModel
        
        print("A Finir: ca marche pas pour le Tableau des Cross-val interne.")
      }
      
      #### Internal k-fold CV ####
      if(External.CV == F){
        #### Specific param ####
        if(is.null(BRT.settings) == F){
          Set.i <- BRT.settings[BRT.settings$Param.clim == names(MClim)[i],]
          if(nrow(Set.i) >= 1){
            if(BRT.ntree.recalcul == F & is.null(Set.i$BRT_ntree) == F){
              BRT.max_trees <- Set.i$BRT_ntree
              Nb.tree <- Set.i$BRT_ntree}
            
            if(BRT.ntree.recalcul == T | is.null(Set.i$BRT_ntree) == T){
              BRT.max_trees <- BRT.max_trees}
            
            if(is.null(Set.i$Learn_rate) == F){BRT.learning_rate<- Set.i$Learn_rate}
            if(is.null(Set.i$Tree_complex) == F){BRT.tree_complexity<- Set.i$Tree_complex}
            if(is.null(Set.i$Min_obs) == F){BRT.minobs <- Set.i$Min_obs}
            
          }
          else{
            print(paste("**** The parameter", names(MClim)[i], "is not found from the BRT setting list. ****"))
            BRT.max_trees <- BRT.max_trees; Nb.tree <- BRT.max_trees
          }
        }
        else{BRT.max_trees <- BRT.max_trees; Nb.tree <- BRT.max_trees}
        
        if(BRT.ntree.recalcul == F){BRT.max_trees <- BRT.max_trees; Nb.tree <- BRT.max_trees}
        
        #### Dismo ####
        if(BRT.package == "dismo"){
          library(dismo)
          print("**** BRT based on Dismo package. ****")
          
          Fit.i <- dismo::gbm.step(data = DB, gbm.x = 2:ncol(DB), gbm.y = 1, family = "gaussian",
                                   verbose = F, call = F, silent = T, plot.main = F,
                                   learing.rate = BRT.learning_rate, keep.fold.fit = T,
                                   tree.complexity = BRT.tree_complexity,
                                   tolerance.method= "fixed", tolerance = 0.1,
                                   n.folds = Internal.K.fold,
                                   max.trees = BRT.max_trees, bag.fraction = BRT.bag_fraction)
          
          Nb.tree <- Fit.i$gbm.call$best.trees
        }
        
        #### GBM (ici c'est en réalité un externe CV) ####
        if(BRT.package == "gbm"){
          library(caret)
          library(gbm)
          
          print("**** BRT based on gbm package. ****")
          DB$RowName <- row.names(DB)
          predictors <- setdiff(names(DB), c("param.climat", "RowName"))
          formula <- as.formula(paste("param.climat ~", paste(predictors, collapse = " + ")))
          
          set.seed(123)
          # folds <- createFolds(DB$param.climat, k = Internal.K.fold)
          
          if(BRT.ntree.recalcul == T){
            Fit.i <- gbm::gbm(data = DB, formula = formula,
                              distribution = "gaussian", n.trees = BRT.max_trees,
                              verbose = Verbose, shrinkage = BRT.learning_rate,
                              train.fraction = BRT.bag_fraction,
                              interaction = BRT.tree_complexity, cv.folds = Internal.K.fold)
            Nb.tree <- gbm.perf(Fit.i, method = "cv", plot.it = F)
          }
          
          Fit.CV <- train(formula, data = DB, method = "gbm", verbose = Verbose, bag.fraction = BRT.bag_fraction,
                          trControl = trainControl(method = "cv", number = Internal.K.fold, verboseIter = Verbose, savePredictions = "all"),
                          # trControl = trainControl(method = "cv", number = Internal.K.fold, verboseIter = Verbose, savePredictions = "all", index = folds),
                          tuneGrid = data.frame(
                            n.trees = Nb.tree,
                            interaction.depth = BRT.tree_complexity,
                            shrinkage = BRT.learning_rate,
                            n.minobsinnode = BRT.minobs))
          
          Fit.i <- Fit.CV$finalModel
          Fit.CV$pred <- Fit.CV$pred[order(Fit.CV$pred$rowIndex),]
          Fit.i$residuals <-  Fit.CV$pred$obs - Fit.CV$pred$pred
        }
      }
      
      #### Export importance ####
      if(BRT.package == "dismo"){
        if(is.null(Fit.i$contributions[2]) == F){influence <- signif(Fit.i$contributions[2], digits = 2)}
        else{influence <- NULL; print("No contribution founded.")}}
      
      if(BRT.package == "gbm" | External.CV == T){
        influence <- summary(Fit.i, plotit = F)
        if(is.null(influence$rel.inf) == F){
          influence <- influence[order(influence$var),]
          influence$rel.inf <- signif(influence$rel.inf, digits = 2)
          influence <- subset(influence, select = -c(var))
        }
        else{influence <- NULL; print("No contribution founded.")}}
      tableWAPLS[[i]] <- Fit.i
    }
    
    #### Tableau synthese des resultats Cross Val interne ####
    if(Model == "WAPLS"){
      AddParam <- performance(Fit.CV)$crossval
      AddParam <- AddParam[c(Min.NB: Nb.arg),] # Pas valide en dessous de Min.NB params
      AddParam[,1] <- signif(AddParam[,1], digits = 3) # on garde juste R2, RMSE
      AddParam[,2] <- signif(AddParam[,2], digits = 2) # on garde juste R2, RMSE
      AddParam <- cbind(NPLS = seq(Min.NB, Nb.arg), AddParam[,1:2], Moran.s.I = seq(Min.NB, Nb.arg), Moran.p.val = seq(Min.NB, Nb.arg), Moran.Expect = seq(Min.NB, Nb.arg), Nb = nrow(MClim))
      
      if(Autocorrel.check == T){
        Clim.reconstruct.sites <- Fit.CV$residuals.cv
        for(x in Min.NB:Nb.arg){
          y <- x - Min.NB + 1
          Spa.auto.i <- Spatial.autocor.check(Mcoord, data.frame(Clim.reconstruct.sites[, x]))
          AddParam[y,4] <- signif(as.numeric(Spa.auto.i[[1]]), digits = 2)
          AddParam[y,5] <- signif(as.numeric(Spa.auto.i[[4]]), digits = 1)
          AddParam[y,6] <- signif(as.numeric(Spa.auto.i[[2]]), digits = 2)
        }}}
    
    if(Model == "MAT"){
      AddParam <- performance(Fit.CV)$crossval[(Nb.arg+1):length(performance(Fit.CV)$crossval[,1]),]
      AddParam <- AddParam[c(Min.NB: Nb.arg),] # Pas valide en dessous de Min.NB
      AddParam[,1] <- signif(AddParam[,1], digits = 3) # on garde juste R2, RMSE
      AddParam[,2] <- signif(AddParam[,2], digits = 2) # on garde juste R2, RMSE
      AddParam <- cbind(Nb.analogue = seq(Min.NB, Nb.arg), AddParam[,1:2], Moran.s.I = NA, Moran.p.val = NA, Moran.Expect = NA, Nb = nrow(MClim))
      if(Autocorrel.check == T){
        Clim.reconstruct.sites <- Fit.CV$residuals.cv
        for(x in Min.NB:Nb.arg){
          y <- x - Min.NB + 1
          Spa.auto.i <- Spatial.autocor.check(Mcoord, data.frame(Clim.reconstruct.sites[, x]))
          AddParam[y,4] <- signif(as.numeric(Spa.auto.i[[1]]), digits = 2)
          AddParam[y,5] <- signif(as.numeric(Spa.auto.i[[4]]), digits = 1)
          AddParam[y,6] <- signif(as.numeric(Spa.auto.i[[2]]), digits = 2)
        }}}
    
    if(Model == "RF"){
      MSE <- Fit.i$mse
      MSE <- MSE[length(MSE)]
      RMSE <- signif(sqrt(MSE), digits = 3)
      R2 <- Fit.i$rsq
      R2 <-  signif(R2[length(R2)], digits = 2)
      AddParam <- cbind(Nb.tree = RF.ntree, RMSE = RMSE, pseudo.R2 = R2, Moran.s.I = NA, Moran.p.val = NA, Moran.Expect = NA, Nb = nrow(MClim))
      if(Autocorrel.check == T){
        Clim.reconstruct.sites <- data.frame(Residual.RF)
        row.names(Clim.reconstruct.sites) <- row.names(MPol)
        Spa.auto.i <- Spatial.autocor.check(Mcoord, data.frame(Clim.reconstruct.sites))
        AddParam[4] <- signif(as.numeric(Spa.auto.i[[1]]), digits = 2)
        AddParam[5] <- signif(as.numeric(Spa.auto.i[[4]]), digits = 1)
        AddParam[6] <- signif(as.numeric(Spa.auto.i[[2]]), digits = 2)
      }}
    
    if(Model == "BRT"){
      if(BRT.package == "dismo"){
        MSE <- Fit.i$cv.statistics$deviance.mean
        MSE <- MSE[length(MSE)]
        
        if(is.null(MSE) == F){RMSE <- signif(sqrt(MSE), digits = 3)}
        else{RMSE <- NULL}
        
        R2 <- round(Fit.i$cv.statistics$correlation.mean^2, digits = 2)
        AddParam <- cbind(Nb.tree = Nb.tree, RMSE = RMSE, pseudo.R2 = R2, Moran.s.I = NA, Moran.p.val = NA, Moran.Expect = NA, Nb = nrow(MClim))
        
        if(Autocorrel.check == T & is.null(Fit.i) == F){
          Clim.reconstruct.sites <- data.frame(Fit.i$residuals)
          row.names(Clim.reconstruct.sites) <- row.names(MPol)
          Spa.auto.i <- Spatial.autocor.check(Mcoord, data.frame(Clim.reconstruct.sites))
          AddParam[4] <- signif(as.numeric(Spa.auto.i[[1]]), digits = 2)
          AddParam[5] <- signif(as.numeric(Spa.auto.i[[4]]), digits = 1)
          AddParam[6] <- signif(as.numeric(Spa.auto.i[[2]]), digits = 2)}
      }
      
      if(BRT.package == "gbm"){
        RMSE <-  signif(Fit.CV$results$RMSE, digits = 3)
        R2 <- signif(Fit.CV$results$Rsquared, digits = 2)
        # RMSE <-  signif(Fit.CV$results$RMSE, digits = 6)
        # R2 <- signif(Fit.CV$results$Rsquared, digits = 6)
        # RMSE <-  Fit.CV$results$RMSE
        # R2 <- Fit.CV$results$Rsquared
        AddParam <- cbind(Nb.tree = Nb.tree, RMSE = RMSE, pseudo.R2 = R2, Moran.s.I = NA, Moran.p.val = NA, Moran.Expect = NA, Nb = nrow(MClim))
        
        if(Autocorrel.check == T & is.null(Fit.i) == F){
          Clim.reconstruct.sites <- data.frame(Fit.i$residuals)
          row.names(Clim.reconstruct.sites) <- row.names(MPol)
          Spa.auto.i <- Spatial.autocor.check(Mcoord, data.frame(Clim.reconstruct.sites))
          AddParam[4] <- signif(as.numeric(Spa.auto.i[[1]]), digits = 2)
          AddParam[5] <- signif(as.numeric(Spa.auto.i[[4]]), digits = 1)
          AddParam[6] <- signif(as.numeric(Spa.auto.i[[2]]), digits = 2)}
      }
    }
    
    #### Tableau result total ####
    Param.clim.lab <- rep(names(MClim)[[i]], length(AddParam[,1]))
    Param.clim.lab.num = paste(Param.clim.lab, 1:length(AddParam[,1]), sep = "_")
    Keep.Nx.name <- row.names(AddParam)
    row.names(AddParam) <- Param.clim.lab.num
    Tab.result <- rbind(Tab.result, AddParam)
    
    #### Choix meilleurs Composant, selon CV ####
    BestR2 <- AddParam[which.max(AddParam[,3]),1]
    BestRMSE <- AddParam[which.min(AddParam[,2]),1]
    Lastcheck <- min(BestR2, BestRMSE, na.rm = T)
    Vam <- data.frame(Best.R2 = BestR2, 
                      Best.RMSE = BestRMSE,
                      Param.choice = Lastcheck,
                      R2.choice = AddParam[AddParam[,1] == Lastcheck, 3],
                      RMSE.choice = AddParam[AddParam[,1] == Lastcheck, 2],
                      I = AddParam[AddParam[,1] == Lastcheck, 4],
                      p.val = AddParam[AddParam[,1] == Lastcheck, 5],
                      Nb = AddParam[AddParam[,1] == Lastcheck, 7]
    )
    row.names(Vam)<- names(MClim)[[i]]
    Best.param <-rbind(Best.param, Vam)
    
    #### Tableau synthese des resultats Cross Val externe (k-fold) ####
    Vam2 <- NULL
    if(External.CV == T){
      if(Model == "RF"){
        Vam2 <- Fit.CV$results[Fit.CV$results$mtry == Fit.CV$bestTune[[1]], c(1:3)]
        names(Vam2)[3] <- "R2"
        Vam2$RMSE <- signif(as.numeric(Vam2$RMSE), digits = 3)
        Vam2$R2 <- signif(as.numeric(Vam2$R2), digits = 2)
        row.names(Vam2)<- names(MClim)[[i]]
        Vam2 <- cbind(Nb.tree = RF.ntree, Vam2)
      }
      if(Model == "BRT"){
        Vam2 <- data.frame(Nb.tree = Nb.tree,
                           Interac.depth = Fit.i$interaction.depth,
                           Learn.rate = Fit.i$shrinkage,
                           RMSE = signif(as.numeric(RMSE), digits = 3), 
                           R2 = signif(as.numeric(R2), digits = 3)
        )
        row.names(Vam2)<- names(MClim)[[i]]
      }
    }
    if(External.CV == F){
      if(Model == "RF"){
        Vam2 <- data.frame(Nb.tree = Fit.i$ntree, Mtry = Fit.i$mtry, RMSE = RMSE, R2 = R2)
        row.names(Vam2)<- names(MClim)[[i]]
      }
      if(Model == "BRT"){
        Vam2 <- data.frame(Nb.tree = Nb.tree,
                           Interac.depth = Fit.i$interaction.depth,
                           Learn.rate = Fit.i$shrinkage,
                           Min_obs = Fit.i$n.minobsinnode, RMSE = RMSE, R2 = R2)
        
        row.names(Vam2)<- names(MClim)[[i]]
      }
    }
    
    #### Return results ####
    return(list(
      fit = Fit.i,
      # impor = Tab.impor.taxa[[i]],
      impor = influence,
      # impor = Tab.impor.taxa,
      param = AddParam,
      best = Vam,
      best2 = Vam2
    ))
  }
  
  #### Loop on climate param. ####
  print(paste(Model, "modellisation is running on the", substitute(MPol), "database.", sep = " "))
  set.seed(123)
  if(Parallelize == T){
    results <- foreach(i = 1:length(MClim), .packages = c("gbm", "caret", "dismo", "rioja", "randomForest"),
                       .export = c("Spatial.autocor.check")) %dorng% {
                         FT.single_run(Model, Min.NB, Nb.arg, i, MClim, MPol, tableWAPLS, External.CV, RF.mtry, External.K.fold, Verbose, Tab.impor.taxa, BRT.settings,
                                       BRT.max_trees, BRT.tree_complexity, BRT.learning_rate, BRT.bag_fraction, BRT.package, BRT.minobs, BRT.ntree.recalcul, Internal.K.fold, Autocorrel.check, 
                                       Mcoord, RF.ntree, Tab.result, Best.param, BRT.remove.constante.var, Transformation)
                       }
    stopCluster(cl)
    registerDoSEQ()
  }
  else{
    results <- list()
    for(i in 1:length(MClim)){
      results[[i]] <- FT.single_run(Model, Min.NB, Nb.arg, i, MClim, MPol, tableWAPLS, External.CV, RF.mtry, External.K.fold, Verbose, Tab.impor.taxa, BRT.settings,
                                    BRT.max_trees, BRT.tree_complexity, BRT.learning_rate, BRT.bag_fraction, BRT.package, BRT.minobs, BRT.ntree.recalcul, Internal.K.fold, Autocorrel.check, 
                                    Mcoord, RF.ntree, Tab.result, Best.param, BRT.remove.constante.var, Transformation)}
  }
  
  #### Result table cleaning ####
  for (i in 1:length(results)) {
    tableWAPLS[[i]] <- results[[i]]$fit
    Tab.impor.taxa[[i]] <- results[[i]]$impor
    Tab.result <- rbind(Tab.result, results[[i]]$param)
    Best.param <- rbind(Best.param, results[[i]]$best)
    Tab.KFCV <- rbind(Tab.KFCV, results[[i]]$best2)
  }
  
  if(Model %in% c("RF","BRT")){Best.param[c(1:3)] <- NA}
  
  yo <- c(names(MClim), "Best.Param")
  tableWAPLS[[length(MClim)+1]] <- Best.param
  names(tableWAPLS) <- yo
  
  if(length(Tab.KFCV) > 0){
    if(External.CV == T){yo <- c(yo, "External.CV.Param")}
    if(External.CV == F){yo <- c(yo, "Settings")}
    tableWAPLS[[length(MClim)+2]] <- Tab.KFCV
    names(tableWAPLS) <- yo
  }
  
  #### Save / export data ####
  Best.param <- as.matrix(Best.param[order(Best.param$R2.choice, decreasing = T),])
  
  if(Save.tab == T){
    Save.path2 <- gsub("\\.csv", "_BestParam.csv", Save.path)
    write.table(Tab.result, file=Save.path, row.names=T, col.names=NA, sep=",", dec = ".")
    write.table(Best.param, file=Save.path2, row.names=T, col.names=NA, sep=",", dec = ".")
    
    if(External.CV == T){
      Save.path3 <- gsub("\\.csv", "_External_CV.csv", Save.path)
      write.table(Tab.KFCV, file=Save.path3, row.names=T, col.names=NA, sep=",", dec = ".")
    }
    
    if(Model %in% c("RF","BRT")){
      Tab.impor.taxa <- as.data.frame(Tab.impor.taxa)
      names(Tab.impor.taxa) <- names(MClim)
      Save.path3 <- gsub("\\.csv", "_Taxa_importance.csv", Save.path)
      write.table(Tab.impor.taxa, file=Save.path3, row.names=T, col.names=NA, sep=",", dec = ".")
    }
    
    if(Save.RDS == T){
      Save.path.RDS <- gsub("\\.csv", ".Rds", Save.path)
      saveRDS(tableWAPLS, Save.path.RDS)}
    
  }
  
  if(Display.final.set == T){print(Tab.KFCV)}
  else{
    if(length(Best.param[,1])>50){print(head(Best.param, n = 50))}
    else{print(Best.param)}
  }
  
  tictoc::toc()
  return(tableWAPLS)
}

Spatial.autocor.check <- function(Mcoord, Mvariable, Show.dup.sites = F){
  #### Initialization value ####
  if(missing(Mcoord)){print("Import the Latitude and the Longitude of the sites.")}
  if(missing(Mvariable)){print("Import the matric of the variables you want to check the autocorrelation.")}
  library("geosphere")
  library("ape")
  
  #### Check size of DB ####
  if(length(setdiff(row.names(Mcoord), row.names(Mvariable))) >=1){
    print(paste("The following site coord doesn't match with the variable :", setdiff(row.names(Mcoord), row.names(Mvariable))))
    Mcoord <- Mcoord[-which(row.names(Mcoord) %in% setdiff(row.names(Mcoord), row.names(Mvariable))),]
  }
  if(length(setdiff(row.names(Mvariable), row.names(Mcoord))) >=1){
    Mvariable <- Mvariable[-which(row.names(Mvariable) %in% setdiff(row.names(Mvariable), row.names(Mcoord))),]}
  
  #### Calcul inverse distance matrix ####
  Lat <- Mcoord[,grep("LAT|lat|Lat", names(Mcoord))]
  Long <- Mcoord[,grep("LONG|long|Long", names(Mcoord))]
  M <- cbind(Long, Lat)
  row.names(M) <- row.names(Mcoord)
  # M.dists <- distm(M, fun = distVincentyEllipsoid)
  M.dists <- as.matrix(dist(M))
  M.dists <- 1/M.dists                         # on inverse
  diag(M.dists) <- 0                   # on mets 0 sur la diagonal
  colnames(M.dists) <- row.names(Mcoord)
  row.names(M.dists) <- row.names(Mcoord)
  
  # /!\ is.finite(M.dists) /!\, il s'agit des sites à coordonnées identiques !
  Same.sites <- data.frame(which(is.finite(M.dists) == F, arr.ind = T))
  Same.sites$row <- row.names(M.dists)[Same.sites$row]
  Same.sites$col <- colnames(M.dists)[Same.sites$col]
  if(Show.dup.sites == T){print(Same.sites)}
  M.dists[is.finite(M.dists) == F] <- 0 
  
  #### Calcule de l'indice Moiran's I #### (Telfort and Birk 2005)
  # test significant if (p < 0.01), SD -> 0 peu de variance au sein DB
  # MI.expected = -1/(n-1)
  # MI.observed > MI.exp -> + auto-correlation spatial positive
  My_Moran.I <- data.frame(I=0, E=0, SD=0, p.val=0)#, z.score=0)
  for(i in 1:length(names(Mvariable))){
    Moran.I.i <- as.matrix(t(ape::Moran.I(Mvariable[,i], M.dists)))
    z.score = (Moran.I.i$I - Moran.I.i$E)/Moran.I.i$SD
    colnames(Moran.I.i) <- names(My_Moran.I)
    row.names(Moran.I.i) <- names(Mvariable)[i]
    My_Moran.I <- rbind(My_Moran.I, Moran.I.i)
  }
  
  My_Moran.I <- My_Moran.I[-1,]
  return(My_Moran.I)
}

Residual.plot <- function(MML = NULL, FT = "BRT", Msurf = NULL, MML.surf.train = NULL, MML.clim.train = NULL, Hexa = T, Dot.size = 1, Calcul.RMSE = F, Manual.titre = NULL,
                          Add.RMSE = F, CV.method = "self", Nb.kfold = 10, Res.bottom = T, Res.right = T, Save.residual = NULL, Add.nb = T, Residual.lims = NULL,
                          Mclim = NULL, Annot = NULL, Save.RMSE = NULL, return.plot = T, model = NULL){
  #### Global settings ####
  if(is.null(Msurf) == F & is.null(Mclim) == F){
    if(identical(row.names(Msurf), row.names(Mclim)) == F){
      print("**** Since you want internal CV, we removed the surface sample not used to train the BRT, in the Mclim data.frame. ****")
      Mclim <- Mclim[row.names(Mclim) %in% row.names(Msurf),]}
  }
  
  #### External CV function ####
  External.CV.calc <- function(FT = "BRT", Msurf, Mclim, MML){
    #### Settings ML ####
    if(FT == "BRT"){
      library(gbm)
      print("****External CV is not available from dismo(), we use gbm() to plot the obs. vs. pred. plot.****")
      training_ml <- function(train_MML.CV, MML, response_var){
        set.seed(123)
        gbm_model <- gbm(
          formula = as.formula(paste(response_var, "~ .")),
          data = train_MML.CV, distribution = MML[[response_var]]$distribution, n.trees = MML[[response_var]]$n.trees,
          interaction.depth = MML[[response_var]]$interaction.depth, shrinkage = MML[[response_var]]$shrinkage, n.minobsinnode = MML[[response_var]]$n.minobsinnode,
          bag.fraction = MML[[response_var]]$bag.fraction, train.fraction = MML[[response_var]]$train.fraction, verbose = F)
        return(gbm_model)
      }
      
      predict_ml <- function(gbm_model, train_MML.CV, MML, response_var){
        preds <- predict(gbm_model, newdata = test_MML.CV, n.trees = MML[[response_var]]$n.trees)
        return(preds)
      }
    }
    
    if(FT == "RF"){
      library(gbm)
      training_ml <- function(train_MML.CV, MML, response_var){
        rf_model <- randomForest(as.formula(paste(response_var, "~ .")), data = train_MML.CV, ntree = MML[[response_var]]$ntree, mtry = MML[[response_var]]$mtry, na.action = na.roughfix, verbose = F)
        return(rf_model)
      }
      
      predict_ml <- function(gbm_model, train_MML.CV, MML, response_var){
        preds <- predict(gbm_model, newdata = test_MML.CV, n.trees = MML[[response_var]]$ntree)
        return(preds)
      }
    }
    
    #### Settings others ####
    library(caret)
    set.seed(123)
    if(is.null(MML.surf.train) == T){MML.surf.train <- Msurf}
    if(identical(MML.surf.train, Msurf) | is.null(Msurf) == T){Combine.intern.extern = F}
    else{Combine.intern.extern = T}
    
    if(is.null(MML.clim.train) == T){
      MML.clim.train <- Mclim
      if(identical(row.names(MML.surf.train), row.names(MML.clim.train)) == F){MML.clim.train <- MML.clim.train[row.names(MML.clim.train) %in% row.names(MML.surf.train),]}
    }
    
    response_var <- names(MML)[1]
    MML.CV <- cbind(MML.surf.train, MML.clim.train[response_var])
    folds <- createFolds(MML.CV[[response_var]], k = Nb.kfold, list = TRUE)
    cv_preds <- rep(NA, nrow(MML.CV))
    
    #### Loop for k-folds ####
    for (i in seq_along(folds)) {
      test_idx <- folds[[i]]
      train_MML.CV <- MML.CV[-test_idx,]
      test_MML.CV <- MML.CV[test_idx,]
      gbm_model <- training_ml(train_MML.CV, MML, response_var) 
      cv_preds[test_idx] <- predict_ml(gbm_model, train_MML.CV, MML, response_var)
    }
    
    #### Combine k-fold (shuffled training/testing set + independant other testing set) ####
    if(Combine.intern.extern == T){
      Msurf_out <- Msurf[!row.names(Msurf) %in% row.names(MML.surf.train),]
      Mclim_out <- Mclim[row.names(Mclim) %in% row.names(Msurf_out),]
      cv_preds_out <- predict(MML[[response_var]], newdata = Msurf_out, n.trees = MML[[response_var]]$n.trees)
      cv_preds <- c(cv_preds, cv_preds_out)
      Mclim <- rbind(MML.clim.train, Mclim_out)
    }
    
    return(list(cv_preds = cv_preds, Mclim = Mclim))
  }
  
  #### Residual calculation ####
  if(is.null(MML) == F){
    #### BRT ####
    if(FT == "BRT"){
      if(CV.method == "external"){
        BRT.res <- External.CV.calc(FT = FT, Msurf, Mclim, MML)
        cv_preds <- BRT.res$cv_preds
        Mclim <- BRT.res$Mclim
        Mconfu1 <- list(BRT = list(cv_preds))
      }
      if(CV.method == "internal"){
        if(is.null(Msurf) == T){Msurf <- MML.surf.train}
        if(is.null(Mclim) == T){Mclim <- MML.clim.train}
        if(nrow(Msurf) == MML$Best.Param$Nb[1]){
          if(is.null(MML[[1]]$fold.fit) == F){Mconfu1 <- list(BRT = list(MML[[1]]$fold.fit))}
          else{
            print("**** Internal CV impossible! The CV result from internal k-fold were not recorded in the BRT list. ****")
            CV.method = "self"
          }
        }
        else{
          print("**** Internal CV impossible! You need to add the same Mpol dataset that the one you used to train the BRT. ****")
          CV.method = "self"
        }
      }
      if(CV.method == "self"){
        if(nrow(Msurf) == MML$Best.Param$Nb[1]){Mconfu1 <- list(BRT = list(MML[[1]]$fit))}
        else{Mconfu1 <- FT.core(Model.BRT = MML, MCore = Msurf, Only.fit = F, Save.RDS = F, Displot = F)
        print("**** Self CV but re-calculating R2 and RMSE from predict(). ****")
        }
      }
      names(Mconfu1$BRT) <- names(MML)[1]
      if(is.null(Msurf) == T){Msurf <- MML.surf.train}
      if(is.null(Mclim) == T){Mclim <- MML.clim.train}
    }
    
    #### RF ####
    if(FT == "RF"){
      if(CV.method == "external"){
        RF.res <- External.CV.calc(FT = FT, Msurf, Mclim, MML) 
        cv_preds <- RF.res$cv_preds
        Mclim <- RF.res$Mclim
        Mconfu1 <- list(RF = list(cv_preds))
      }
      if(CV.method == "internal"){
        if(is.null(Msurf) == T){Msurf <- MML.surf.train}
        if(is.null(Mclim) == T){Mclim <- MML.clim.train}
        if(nrow(Msurf) == MML$Best.Param$Nb[1]){Mconfu1 <- list(RF = list(MML[[1]]$predicted))}
        else{
          print("**** Internal CV impossible! You need to add the same Mpol dataset that the one you used to train the BRT. ****")
          CV.method = "self"
        }
      }
      if(CV.method == "self"){
        # if(nrow(Msurf) == MML$Best.Param$Nb[1]){Mconfu1 <- list(RF = list(MML[[1]]$predicted))}
        # else{
        Mconfu1 <- FT.core(Model.RF = MML, MCore = Msurf, Only.fit = F, Save.RDS = F, Displot = F)
        print("**** Self CV but re-calculating R2 and RMSE from predict(). ****")
        # }
      }
      names(Mconfu1$RF) <- names(MML)[1]
      if(is.null(Msurf) == T){Msurf <- MML.surf.train}
      if(is.null(Mclim) == T){Mclim <- MML.clim.train}
    }
    #### MAT ####
    if(FT == "MAT"){
      Mconfu1 <- FT.core(Model.MAT = MML, MCore = Msurf, Only.fit = F, Save.RDS = F, Displot = F)
    }
    
    #### WAPLS ####
    if(FT == "WAPLS"){
      Mconfu1 <- FT.core(Model.WAPLS = MML, MCore = Msurf, Only.fit = F, Save.RDS = F, Displot = F)
    }
    
    Mconfu1 <- do.call(rbind, lapply(Mconfu1, as.data.frame))
    Mconfu1$Sites <- row.names(Mconfu1)
    Mconfu1 <- setNames(data.frame(reshape2::melt(Mconfu1, id = "Sites")), c("Sites", "Pred.clim.lab", "Pred.clim.val"))
    
    Mconfu1.clim <- Mclim[match(levels(Mconfu1$Pred.clim.lab), names(Mclim))]
  }
  else{
    Mconfu1 <- Msurf
    Mconfu1$Sites <- row.names(Msurf)
    Mconfu1 <- setNames(data.frame(reshape2::melt(Mconfu1, id = "Sites")), c("Sites", "Pred.clim.lab", "Pred.clim.val"))
    Mconfu1$Calib <- Mconfu1$Pred.clim.lab
    Mconfu1$Pred.clim.lab <- gsub("_.*", "", Mconfu1$Pred.clim.lab)
    
    Mconfu1.clim <- Mclim[match(unique(Mconfu1$Pred.clim.lab), names(Mclim))]
  }
  Mconfu1.clim$Sites <- unique(Mconfu1$Sites)
  Mconfu1.clim <- setNames(data.frame(reshape2::melt(Mconfu1.clim, id = "Sites")), c("Sites", "Obs.clim.lab", "Obs.clim.val"))
  
  Mconfu1 <- cbind(Mconfu1, Mconfu1.clim[3])
  Mconfu1$Residuals <- (Mconfu1$Obs.clim.val - Mconfu1$Pred.clim.val)
  
  if(is.null(MML) == T){
    Mconfu1 <- subset(Mconfu1, select = -c(Pred.clim.lab))
    names(Mconfu1)[names(Mconfu1) == "Calib"] <- "Pred.clim.lab"
    Mconfu1 <- Mconfu1[c(1,3,2,4,5)]
  }
  
  #### Residual scaling ####
  Mconfu1_scaled <- Mconfu1 %>%
    dplyr::group_by(Pred.clim.lab) %>%
    mutate(Residuals.sc = (Residuals - mean(Residuals)) / sd(Residuals))
  
  #### RMSE calculation ####
  if(Calcul.RMSE == T | Add.RMSE == T){
    MRes <- Mconfu1[c("Sites", "Pred.clim.lab", "Residuals")]
    MRes <- reshape2::dcast(MRes, Sites ~ Pred.clim.lab, value.var = "Residuals")
    MRes <- sqrt(colSums(subset(MRes, select = - c(Sites))^2)/nrow(MRes))
    
    if(is.null(Save.RMSE) == F){
      print("Local RMSE for each calibration:")
      print(MRes)
      saveRDS(MRes, Save.RMSE)
    }
  }
  else{MRes <- NULL}
  
  #### Lim settlement ####
  Mlims <- Mconfu1[names(Mconfu1) %in% c("Pred.clim.lab", "Pred.clim.val", "Obs.clim.val")]
  Mlims <- rbind(setNames(Mlims[c(1,2)], c("Pred.clim.lab", "B")), setNames(Mlims[c(1,3)], c("Pred.clim.lab", "B")))
  Mlims <- Mlims %>%
    dplyr::group_by(Pred.clim.lab) %>%
    dplyr::summarize(
      xlim = min(B),
      ylim = max(B)
    )
  Mlims <- reshape2::melt(Mlims, id = "Pred.clim.lab")
  Mlims$Sites <- "Dummy.dot"
  Mlims <- subset(Mlims, select = -c(variable))
  Mlims$Obs.clim.val <- Mlims$value
  Mlims$Obs.clim.lab <- Mlims$Pred.clim.lab
  Mlims$Residuals <- 0
  names(Mlims)[names(Mlims) == "value"] <- "Pred.clim.val"
  
  Mlims <- Mlims[match(names(Mconfu1), names(Mlims))]
  # Mconfu1 <- rbind(Mconfu1, Mlims)
  Mlims$Residuals.sc <- 0
  # Mconfu1_scaled <- rbind(Mconfu1_scaled, Mlims)
  
  #### Global graphical param ####
  New.lab1 <- New.lab[match(levels(Mconfu1$Pred.clim.lab), names(New.lab))]
  
  if(all(is.na(unique(New.lab1)))){
    New.lab1 <- levels(Mconfu1$Pred.clim.lab)
    New.lab1 <- paste(sub("_", "~(", New.lab1), ")", sep = "")
    New.lab1 <- sub("_", "~", New.lab1)
    New.lab1 <- gsub("5Me", "[5*Me]", New.lab1)
    New.lab1 <- gsub("~\\[", "[", New.lab1)
  }
  
  if(is.null(model) == F){
    Ytitle <- paste(model, "predictions")
  }
  else{Ytitle <- "Predicted \nclimate parameters"}
  
  if(Hexa == T){My_dots <- geom_hex(bins = 30, aes(fill = ..count..))}
  else{My_dots <- geom_point(color = "grey50", size = Dot.size)}
  
  New.lab <- c("d13Corg" = "paste(delta^13,C[TOC])", "d13Ctot" = "paste(delta^13,C[tot])", "d15Ntot" = "paste(delta^15,N[tot])", "A: Core sections" = "MasterCore",
               "Corg.N_atom" = "C/N", "X.C_inorg_DeltaM" = "TIC", "wt..Ntot" = "wt~'%N'[tot]",
               "Fe/Al" = "Fe/Al", "Rb/Sr" = "Rb/Sr", "Ti/Al" = "Ti/Al", "K/Ca" = "K/Ca", "C14" = "paste(Dating^14,C)",
               "L" = "L\\*", "RABD660_670" = "RABD[660-670]", "Q7.4" = "Q[700/400]", "Chlo_a" = "Chlo[a]~(mg.g^-1)",
               "MAAT" = "MAAT (degree*C)", "MAF" = "MAF (degree*C)", "MAP" = "MAP~(mm.yr^-1)",  "MPCOQ" = "MPCOQ~(mm.yr^-1)", "Altitude" = "Altitude", "AI" = "AI", "Pspr" = "P[spring]~(mm.yr^-1)",
               "IIIa.IIa" = "Sigma(IIIa/IIa)", "Ib.Ia" = "Ib/Ia", "IR6_7Me" = "IR[6+7~Me]","IRp6_7Me" = "IRp[6+7~Me]", "GDGT0.Crenar" = "GDGT[0]/Crenar", "pCren" = "\'%\'[Cren]",
               # "Art_Ama/Poa" = "(Ar.+Amar.)/Poa.", "Poa/Ama" = "Poa./Amar.", "Ama/Art" = "Amar./Ar.", "Art/Ama+Art" = "Ar./(Amar.+Ar.)", "Art+Ama/Poa" = "(Ar.+Amar.)/Poa.", "Poa/Art" = "Poa./Ar.",
               "Art_Ama/Poa" = "over((Artemisia+Amaranth.), Poaceae)", "Poa/Ama" = "over(Poaceae, Amaranthaceae)", "Ama/Art" = "over(Amaranthaceae,Artemisia)", "Art/Ama+Art" = "over(Artemisia,(Amaranthaceae+Artemisia))", "Art+Ama/Poa" = "over((Artemisia+Amaranthaceae),Poaceae)", "Poa/Art" = "over(Poaceae,Artemisia)", "AP/NAP" = "over(Arboreal~Pollen, Non-Arboreal~Pollen)",
               "PC1" = "PC1[XRF]", "PC2" = "PC2[XRF]", "MS" = "MS~(10^-5~SI)", "Sus_mag" = "")
  
  if(is.null(Residual.lims) == F){
    Res.lim.r <- xlim(Residual.lims)
    Res.lim.b <- ylim(Residual.lims)
    
  }
  else{Res.lim.b <- NULL; Res.lim.r <- NULL}
  
  if(Res.bottom == T){Myaxis.x <- element_blank()}
  else{Myaxis.x <- element_line()}
  
  #### Plotting loops ####
  plots <- list()
  for(i in 1:length(unique(Mconfu1$Pred.clim.lab))){
    #### Param i ####
    Param <- unique(Mconfu1$Pred.clim.lab)[i]
    New.lab1.i <- New.lab1[i]
    if(is.null(Annot) == F){New.lab1.i <- paste("(", Annot[i], ")~", New.lab1.i, sep = "")}
    Mconfu.i <- Mconfu1[Mconfu1$Pred.clim.lab == Param,]
    Mconfu1_scaled.i <- Mconfu1_scaled[Mconfu1_scaled$Pred.clim.lab == Param,]
    
    if(i == 1){Ylab <- element_text()}
    if(i > 1){Ylab <- element_blank()}
    
    #### Add Annotation ####
    if(Add.RMSE == T){
      R2 <- summary(lm(Pred.clim.val ~ Obs.clim.val, data = Mconfu.i))$r.squared
      
      label_text <- paste0("R^2==", signif(R2, 2), "*','~RMSE==", signif(MRes[[i]], 2))
      
      if(Add.nb == T){
        n_obs <- length(Mconfu.i$Obs.clim.val)
        label_text <- paste0("R^2==", signif(R2, 2), "*','~RMSE==", signif(MRes[[i]], 2), "*','~n==", n_obs)
      }
      Annotate.R2 <- annotate("text", x = Inf, y = -Inf, label = label_text, hjust = 1.1, vjust = -1, parse = TRUE, size = 3)
    }
    else{Annotate.R2 <- stat_poly_eq(size = 3, vstep = 0.07, label.y = "bottom", label.x = "right")}
    
    #### Manual title ####
    if(is.null(Manual.titre) == F){
      if(is.null(Annot) == F){Manual.titre <- paste("(", Annot[i], ")~", Manual.titre, sep = "")}
      
      New.lab1.i[1] <- Manual.titre
    }
    
    #### Plot (main) ####
    p.main <- ggplot(Mconfu.i, aes(x = Obs.clim.val, y = Pred.clim.val)) +
      My_dots +
      geom_point(data = Mlims, color = NA, fill = NA)+
      geom_smooth(method = "lm", se = F, linewidth = 0.7, formula = 'y ~ x') +
      scale_fill_gradientn(name = "Nb. obs.",
                           colors = c("grey90", "royalblue", "darkorange", "darkred"),  # Discrete color steps
                           values = scales::rescale(c(0, 1, 10, 100)),  # Scale the breaks
                           breaks = c(0, 1, 10, 100)) +
      geom_abline(slope = 1, intercept = 0, color = "grey20", linetype = "dashed") + 
      labs(x = NULL, 
           y = Ytitle) + 
      ggtitle(parse(text = New.lab1.i[1]))+
      Annotate.R2 +
      theme(panel.background = element_rect(fill = NA, colour = 'black', linewidth = .5), panel.border = element_blank(), strip.background = element_blank(), strip.text = element_text(size = 13),
            legend.position = "none", panel.grid = element_line(colour = "grey80", linetype = 2, linewidth = .1),
            axis.text.x = element_blank(),
            axis.title.y = Ylab, axis.ticks.x = Myaxis.x,
            axis.line.x = element_blank())
    
    #### Plot bottom (residuals) ####
    if(Res.bottom == T){
      presidu.b <- ggplot(Mconfu1_scaled.i, aes(x = Obs.clim.val, y = Residuals)) +
        geom_point(aes(color = Residuals), size = Dot.size) +
        geom_point(data = Mlims, color = NA, fill = NA)+
        geom_hline(yintercept = 0, lty = "dashed")+
        labs(x = "Observed climate parameters",
             y = "Residuals") + Res.lim.b +
        scale_color_gradient2(name = "Residual (z-scores)",
                              low = "#963327",
                              mid = "white",
                              high = "#963327",
                              midpoint = 0,
                              limit = c(-max(abs(Mconfu1_scaled.i$Residuals)), max(abs(Mconfu1_scaled.i$Residuals))))+
        theme(
          plot.background = element_blank(), plot.margin = unit(c(0,0,0,0), 'pt'),
          axis.title.y = Ylab,
          legend.position = "none", panel.grid = element_line(colour = "grey80", linetype = 2, linewidth = .1),
          panel.background = element_rect(fill = NA, colour = 'black'), panel.border = element_blank(),
          strip.text = element_blank(), strip.background = element_blank())
      
      p <- (p.main / presidu.b)+ plot_layout(nrow = 2, heights = c(.8,.2))
    }
    
    #### Plot right (residuals) ####
    if(Res.right == T){
      presidu.r <- ggplot(Mconfu1_scaled.i, aes(y = Pred.clim.val, x = Residuals)) +
        geom_point(aes(color = Residuals), size = Dot.size) +
        geom_point(data = Mlims, color = NA, fill = NA)+
        geom_vline(xintercept = 0, lty = "dashed")+
        labs(y = "Predicted climate parameters",
             x = "Residuals") + Res.lim.r +
        scale_color_gradient2(name = "Residual (z-scores)",
                              low = "#963327",
                              mid = "white",
                              high = "#963327",
                              midpoint = 0,
                              limit = c(-max(abs(Mconfu1_scaled.i$Residuals)), max(abs(Mconfu1_scaled.i$Residuals))))+
        theme(
          plot.background = element_blank(),  plot.margin = unit(c(0,0,0,0), 'pt'),
          axis.title.y = element_blank(),
          axis.title.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank(),
          legend.position = "none", panel.grid = element_line(colour = "grey80", linetype = 2, linewidth = .1),
          panel.background = element_rect(fill = NA, colour = 'black'), panel.border = element_blank(),
          strip.text = element_blank(), strip.background = element_blank())
      
      if(Res.bottom == F){p <- (p.main | presidu.r)+ plot_layout(ncol = 2, widths = c(.75,.25))}
      else{
        p.dummy <- ggplot(Mconfu1_scaled.i, aes(y = Pred.clim.val, x = Residuals)) + Res.lim.b + Res.lim.r +
          theme(plot.background = element_blank(),  plot.margin = unit(c(0,0,0,0), 'pt'), axis.title = element_blank(), panel.border = element_blank(),
                axis.text = element_blank(), axis.ticks = element_blank(), legend.position = "none", panel.grid = element_blank(),
                panel.background = element_blank(), strip.text = element_blank(), strip.background = element_blank())
        
        p.main <- p.main + theme(plot.margin = ggplot2::margin(0,0,0,0))
        presidu.r <- presidu.r + theme(plot.margin = ggplot2::margin(0,0,0,0))
        presidu.b <- presidu.b + theme(plot.margin = ggplot2::margin(0,0,0,0))
        p.dummy <- p.dummy + theme(plot.margin = ggplot2::margin(0,0,0,0))
        
        p <- ((p.main | presidu.r) + plot_layout(widths = c(0.8, 0.2))) /
          ((presidu.b | p.dummy) + plot_layout(widths = c(0.8, 0.2))) +
          plot_layout(heights = c(0.8, 0.2)) # only heights at top level
      }
    }
    
    if(Res.bottom == F & Res.right == F){p <- p.main}
    plots[[i]] <- p
  }
  plots <- wrap_plots(plots)
  
  #### Export ####
  if(is.null(Save.residual) == F){saveRDS(Mconfu.i, Save.residual)}
  if(return.plot == T){return(plots)}
  else{return(Mconfu.i)}
  
}

Residual_analysis <- function(Res.list = NULL, Save.path = NULL, Export.latex = F) {
  #### Clean data ####
  library(moments)
  KN <- names(Res.list)
  Res.list <- lapply(names(Res.list), function(nm) {df <- Res.list[[nm]]; df <- as.double(df[[ncol(df)]]); return(df)})
  names(Res.list) <- KN
  
  #### My functions ####
  p_to_star <- function(p) {
    # if(is.na(p)) return(NA)
    if(p < 0.0001){return("***")}
    else if (p < 0.001) return("**")
    else if (p < 0.01) return("*")
    else if (p < 0.1) return(".")
    else return(" ")
  }
  
  residual_summary <- function(res) {
    data.frame(
      Mean     = round(mean(res), digits = 2),
      Median   = round(median(res), digits = 2),
      Min      = round(min(res), digits = 1),
      Max      = round(max(res), digits = 1),
      Skewness = round(skewness(res), digits = 2),
      Kurtosis = round(kurtosis(res), digits = 2),
      # Shapiro.p = tryCatch(shapiro.test(res)$p.value, error = function(e) NA),
      "Shapiro p-value" = p_to_star(shapiro.test(res)$p.value),
      RMSE     = round(sqrt(mean(res^2)), digits = 2)
    )
  }
  
  #### Run on the list of residuals ####
  residuals_summary_df <- do.call(rbind, lapply(Res.list, residual_summary))
  rownames(residuals_summary_df) <- names(Res.list)
  
  #### Export ####
  if(is.null(Save.path) == F){
    write.table(residuals_summary_df, Save.path, row.names = F)
    if(is.null(Export.latex) == F){
      library(xtable)
      LateX.caption <- "Statistical analysis of the residuals for the MAAT predictions: residuals distribution (mean, median, minimum and maximum values), skewness, kurtosis, Shapiro test \\textit{p}-value and RMSE. The results show the three BRT and three RF models and three linear calibrations from XXXX."
      Save.path.tex <- gsub("\\.csv", "\\.tex", Save.path)
      names(residuals_summary_df) <- c(names(residuals_summary_df)[c(1:6)], "Shapiro \\textit{p}-value", "RMSE")
      Tlatex <- xtable(residuals_summary_df, caption = LateX.caption, type = "latex", label = "SI_Table_res")
      print(Tlatex, file = Save.path.tex, booktabs = T, include.rownames = T, comment = F,
            caption.placement = "top", sanitize.text.function = function(x){x}, hline.after = )
    }
  }
  
  print(residuals_summary_df)
  return(residuals_summary_df)}

# Correlation matrice between GDGT and Clim param.
Mat.corel <- function(MGDGT, MClim, I.confiance, Display.pval, Display = "full", Disp.R, 
                      Label.simple, Label = T, Title, Save.path, Save.plot, W, H){
  #### Settings ####
  Save.tab = T
  library(corrplot)
  if(missing(I.confiance)){I.confiance = 0}
  if(missing(Save.path)){Save.tab = F}
  if(missing(Save.plot)){Save.plot = NULL}
  if(missing(W)){W = NULL}
  if(missing(H)){H = NULL}
  if(missing(Display.pval)){Display.pval = "pch"}
  if(missing(Disp.R)){Disp.R = "pie"}
  if(missing(MClim)){MClim = NULL}
  if(missing(Title)){Title = NULL}
  if(Display.pval == "blank"){Subt = paste("*The cells are blanked when ever the p-value is over the", I.confiance, "significant level.")}
  if(Display.pval == "pch"){Subt = paste("*The cells are crossed when ever the p-value is over the", I.confiance, "significant level.")}
  if(missing(Label.simple)){Label.simple = T}
  if(Label == F){Subt <- NULL}
  
  #### Label type ####
  if(Label.simple == T){
    # print(MGDGT)
    AZER <- gsub("^f.", "", names(MGDGT))
    AZER <- gsub("_5Me", "", AZER)
    AZER <- gsub("_6Me", "\\'", AZER)
    AZER <- gsub("_7Me", "\\''", AZER)
    AZER <- gsub("_8Me", "\\'''", AZER)
    names(MGDGT)  <- AZER
  }
  
  #### Calculations ####
  # Mcor <- cor(MGDGT, MClim)
  # Mcor <- cor(MGDGT, MClim, use = "pairwise.complete.obs")
  Mcor <- cor(MGDGT, MClim, use = "complete.obs")
  Mvar <- var(MGDGT, MClim)
  Mtot <- cbind(MClim, MGDGT)
  Resid <- cor.mtest(Mtot, conf.level = I.confiance)
  PV <- Resid$p
  if(is.null(MClim) == F){PV <- PV[(ncol(MClim)+1):(ncol(MClim)+ncol(MGDGT)), 1:ncol(MClim)]} 
  row.names(PV) <- row.names(Mcor)
  colnames(PV) <- colnames(Mcor)
  
  #### Save plots ####
  if(is.null(Save.plot) == F){
    if(is.null(W) == F & is.null(H) == F){
      pdf(file = Save.plot, width = W*0.01041666666667, height = H*0.01041666666667)}
    else{pdf(file = Save.plot)}}
  
  #### Plots ####
  CP <- corrplot(Mcor, col = rev(COL2(c("RdBu"), n = 200)),
                 tl.col="black", tl.srt=45, tl.cex = .7, method = Disp.R, type = Display,
                 p.mat = PV, sig.level = (1-I.confiance), insig = Display.pval, pch.cex = 2)
  
  title(main = Title, sub = Subt)
  Mfull <- list(R2 = Mcor, Var = Mvar, p.val = PV)
  
  #### Export datas ####
  if(Save.tab == T){
    Path.to.create <- gsub("(.*/).*\\.csv.*","\\1", Save.path)
    dir.create(file.path(Path.to.create), showWarnings = FALSE)
    write.table(Mfull, file = Save.path, row.names=T, col.names=NA, sep=",", dec = ".")}
  
  #### Return ####
  if(is.null(Save.plot) == F){dev.off()}
  return(Mfull)
}

Plot.partial.dependance <- function(Mclim = NULL, Msurf = NULL, FT = NULL, Selected.biplots = NULL, PD.show.predictor = NULL,
                                    Resolution = 10, Param.clim = "MAAT", Annotate.plots = T, Interaction.order = "interaction",
                                    Color.by.importance = F, Sqrt.scale = F, Add.interaction.plot = F, Facet.by.cyclisation = F, 
                                    Facet.by.methylation = F, Add.repel = F, Add.biplot.PD = F, Alpha.density = F, Free.scale = F,
                                    Rel.Width.interac.plot = 70, Rel.Height.interac.plot = 70, PD.biplot.ggplot = T,
                                    Save.plot = NULL, Save.Rds = NULL, H = 1200, W = 800){
  
  #### RF or BRT ####
  if(class(FT[[Param.clim]]) == "gbm"){
    Ntrees <- FT[[Param.clim]]$n.trees
    importance_vec <- as.matrix(summary(FT[[Param.clim]])[c(2)])
  }
  if(class(FT[[Param.clim]]) == "randomForest"){
    Ntrees <- FT[Param.clim]$ntree
    importance_vec <- FT[[Param.clim]]$importance
  }
  
  #### Data cleaning ####
  Predictor.selection <- names(Msurf)
  DB <- cbind(Msurf, Mclim[Param.clim])
  print("Partial dependence calculation.")
  
  pd_list <- purrr::map(Predictor.selection, ~ pdp::partial(FT[[Param.clim]], pred.var = .x, train = DB, 
                                                            n.trees = Ntrees,
                                                            grid.resolution = Resolution))
  
  names(pd_list) <- Predictor.selection
  merged_df <- Reduce(function(x, y) merge(x, y, by = "yhat", all = TRUE), pd_list)
  merged_df <- reshape2::melt(merged_df, id = "yhat")
  merged_df <- na.omit(merged_df)
  merged_df$variable <- gsub("_6Me", "'", gsub("f.|_5Me", "", merged_df$variable))
  
  if(is.null(PD.show.predictor) == F){merged_df <- merged_df[merged_df$variable %in% PD.show.predictor,]}
  
  #### Color ####
  if(Color.by.importance == T){
    importance_vec <- importance_vec[Predictor.selection,]
    names(importance_vec) <- gsub("_6Me", "'", gsub("f.|_5Me", "", names(importance_vec)))
    importance_scaled <- (importance_vec - min(importance_vec)) / (max(importance_vec) - min(importance_vec))
    color_palette <- colorRampPalette(c("darkred", "royalblue", "grey90"))(length(importance_scaled))
    names(color_palette) <- names(sort(importance_scaled, decreasing = T))  # sorted by importance
    merged_df$variable <- factor(merged_df$variable, levels = names(sort(importance_scaled, decreasing = T)))
    plot_colors <- color_palette[as.character(unique(merged_df$variable))]
    My_color_scale <-   scale_color_manual(values = plot_colors)
    My_fill_scale <-   scale_fill_manual(values = plot_colors, name = "brGDGTs (sorted by importance)")
  }
  else{My_color_scale <- NULL; My_fill_scale <- NULL}
  
  #### Scale ####
  if(Sqrt.scale == T){
    merged_df$value <- sqrt(merged_df$value*100)
  }
  
  #### Facet by methylation/cyclisation number ####
  if(Facet.by.cyclisation == T | Facet.by.methylation == T){
    merged_df$Cycle <- NA
    
    if(Facet.by.cyclisation == T){
      merged_df$Cycle <- ifelse(grepl("c", merged_df$variable), "2 cyclisations",
                                ifelse(grepl("b", merged_df$variable), "1 cyclisation", "No cyclisation"))
    }
    else{merged_df$Cycle <- "Penta-/Hexamethylated"}
    
    if(Facet.by.methylation == T){
      merged_df$Cycle[merged_df$variable %in% c("Ia", "Ib", "Ic")] <- "Tetramethylated"
      if(Facet.by.cyclisation == T){merged_df$Cycle <- factor(merged_df$Cycle, levels = c("Tetramethylated", "No cyclisation", "1 cyclisation", "2 cyclisations"))}
      else{merged_df$Cycle <- factor(merged_df$Cycle, levels = c("Tetramethylated", "Penta-/Hexamethylated"))}
    }
    else{merged_df$Cycle <- factor(merged_df$Cycle, levels = c("No cyclisation", "1 cyclisation", "2 cyclisations"))}
    
    if(Free.scale == T){My_facet <- ggforce::facet_col(~ Cycle, scales = "free", space = "free", strip.position = "right")}
    else{My_facet <- facet_grid(Cycle~., space = "free")}
  }
  else{My_facet <- NULL}
  
  #### Repel ####
  if(Add.repel == T){
    max_points <- merged_df %>%
      group_by(variable) %>%
      filter(value == max(value)) %>%
      ungroup()
    
    My_repel <- ggrepel::geom_text_repel(data = max_points, aes(label = variable, color = variable), direction = "y", 
                                         hjust = -0.5, #vjust = 2,
                                         force = 100, min.segment.length = 3000,
                                         # na.rm = T, xlim = max(merged_df$value),
                                         # segment.square = F, segment.shape = 1, segment.linetype = 4, segment.size = 0.1, segment.colour = "grey50",
                                         # segment.curvature = 0.2, segment.inflect = F, min.segment.length = 0.5, 
                                         size = 4.5, parse = F
    )
    
  }
  else{My_repel <- NULL}
  
  #### Annotations ####
  if(Annotate.plots == T){My_title <- element_text()}
  else{My_title <- element_blank()}
  
  #### Alpha as density of observations (CA MARCHE PAS) ####
  if(Alpha.density == T){
    
    # breaks <- c(-Inf, unique(merged_df$value), Inf)
    # bin_labels <- levels(cut(0, breaks, include.lowest = TRUE))  # get all factor levels
    # bin_means <- c(2.5, 7.5, 30, 75)  # Example: midpoints for (-Inf,5], (5,10], (10,50], (50,Inf]
    bin_mean <- unique(merged_df$value)
    cuts <- (head(bin_mean, -1) + tail(bin_mean, -1)) / 2
    breaks <- c(-Inf, cuts, Inf)
    
    # Melt df
    Msurf_dens <- Msurf %>%
      pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
      mutate(
        bin = cut(value, breaks = breaks, include.lowest = TRUE, right = TRUE),
        bin_mean = unique(merged_df$value)[as.numeric(bin)]
      )
    
    # Step 3: Create lookup table
    bin_lookup <- data.frame(
      bin = factor(bin_labels, levels = bin_labels),
      bin_mean = bin_means
    )
    
    # Step 4: Join to df_long
    df_long <- df %>%
      pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
      mutate(bin = cut(value, breaks = breaks, include.lowest = TRUE, right = TRUE)) %>%
      left_join(bin_lookup, by = "bin")
    
    
    
    
    
    #
    breaks <- c(-Inf, , Inf)
    
    Msurf_dens <- Msurf %>%
      pivot_longer(cols = everything(), names_to = "variable", values_to = "value") %>%
      mutate(bin = cut(value, breaks = breaks, include.lowest = TRUE, right = TRUE))
    
    
    A_cut <- cut(Msurf[[c(1)]], breaks = breaks, right = TRUE, include.lowest = TRUE)
    df <- data.frame(A = Msurf[[c(1)]], bin = A_cut)
    geom_line(color = "grey")
  }
  else{
    My_lines <- geom_line(aes(color = variable))
    My_dots <- geom_point(aes(color = variable), size = 1, alpha = .6, shape = 20)
  }
  
  
  #### Plot Partial dependence ####
  PD <- ggplot(merged_df, aes(x = value*100, y = yhat)) + 
    My_lines +
    My_dots +
    My_facet + My_repel +
    My_color_scale + #My_scale +
    # facet_wrap(~ Predictor.selection, scales = "free_x") +
    labs(x = "brGDGT fractional abundances (%)", y = paste("Predicted", Param.clim, "(y)"),
         title = "(A)") +
    # theme_minimal() +
    theme(panel.background = element_rect(fill = NA, color = "grey"), panel.grid = element_blank(), 
          strip.text = element_text(size = 11), legend.position = "none", 
          strip.background = element_blank(),
          axis.text = element_text(size = 9), plot.title = My_title,
          panel.border = element_rect(fill = NA, colour = "black", linewidth = .5),
          axis.ticks = element_line(colour = "black", linewidth = .5),
          axis.title = element_text(size = 13)
    )
  
  #### brGDGT interaction ####
  if(Add.interaction.plot == T){
    library(iml)
    print("Interraction calculation (H-statistic).")
    predictor <- Predictor$new(model = FT[[Param.clim]],data = Msurf[Predictor.selection], y = Mclim[Param.clim])
    interaction_obj <- Interaction$new(predictor)
    interaction_df <- interaction_obj$results  # data.frame with 'feature' and 'importance'
    names(interaction_df) <- c("feature", "interaction")
    interaction_df$feature <- gsub("_6Me", "'", gsub("f.|_5Me", "", interaction_df$feature))
    
    if(Color.by.importance == T){interaction_df$feature <- factor(interaction_df$feature, levels = names(sort(importance_scaled, decreasing = T)))}
    
    if(Interaction.order == "interaction"){interaction_df$feature2 <- factor(interaction_df$feature, levels = interaction_df$feature[order(interaction_df$interaction)])}
    if(Interaction.order == "importance"){interaction_df$feature2 <- factor(interaction_df$feature, levels = names(sort(importance_scaled)))}
    if(Interaction.order == "normal"){interaction_df$feature2 <- factor(interaction_df$feature, levels = rev(gsub("_6Me", "'", gsub("f.|_5Me", "", Predictor.selection))))}
    
    if(is.null(PD.show.predictor) == F){interaction_df <- interaction_df[interaction_df$feature2 %in% PD.show.predictor,]}
    
    Pinterac <- ggplot(interaction_df, aes(x = feature2, y = interaction, fill = feature)) +
      geom_col(width = .2) +
      coord_flip() +
      My_fill_scale +
      labs(x = "brGDGT compounds", y = "Interaction strength (H-statistic)",
           title = "(B)") +
      guides(fill = guide_legend(nrow = 1, title.position = "top"))+
      theme(panel.background = element_rect(fill = NA, color = "grey"), panel.grid = element_blank(), 
            # strip.text = element_text(size = 11), 
            strip.text = element_text(size = 11, face = "bold", margin = ggplot2::margin(t = 5, b = 5)),
            legend.key = element_blank(), legend.position = "bottom", legend.direction = "horizontal", legend.background = element_blank(),
            legend.margin = ggplot2::margin(0,0,0,0), legend.byrow = T, legend.text.position = "top", legend.text = element_text(size = 12),
            axis.text = element_text(size = 10), plot.title = My_title, strip.clip = "off",
            panel.border = element_rect(fill = NA, colour = "black", linewidth = .5),
            axis.ticks = element_line(colour = "black", linewidth = .5),
            axis.title = element_text(size = 13)
      )
    
    if(Add.biplot.PD == T){PD2 <- (PD / Pinterac) + plot_layout(heights = c(Rel.Width.interac.plot, 100 - Rel.Width.interac.plot))}
    else{PD2 <- (PD | Pinterac) + plot_layout(widths = c(Rel.Width.interac.plot, 100 - Rel.Width.interac.plot), guides = "collect") & 
      guides(fill = guide_legend(nrow = 1, title.position = "top"), color = "none") &
      theme(legend.position = "bottom", plot.title = My_title)}
  }
  else{PD2 <- PD; predictor <- NULL}
  
  #### Add biplot 2-ways ####
  if(Add.biplot.PD == T){
    #### Automatic selection of the 4 best biplots #### 
    if(is.null(Selected.biplots) == T){
      #### Test all the 2-ways interaction (with Freiman H) ####
      library(iml)
      print("Automatic selection of the Partial Dependance biplots (2-ways) for the 4th better one.")
      if(is.null(predictor) == T){predictor <- Predictor$new(model = FT[[Param.clim]],data = Msurf[Predictor.selection], y = Mclim[Param.clim])}
      pairwise_interactions <- data.frame(Feature1 = character(), Feature2 = character(), H = numeric(), stringsAsFactors = F)
      
      for (f in names(Msurf)){
        interact <- Interaction$new(predictor, feature = f, grid.size = Resolution)
        temp <- data.frame(Feature1 = f, Feature2 = interact$results$.feature, H = interact$results$.interaction)
        pairwise_interactions <- rbind(pairwise_interactions, temp)
      }
      
      pairwise_interactions$Feature2 <- gsub(":.*", "", pairwise_interactions$Feature2)
      pairwise_interactions$pair_id <- apply(pairwise_interactions[, c("Feature1", "Feature2")], 1, function(x) paste(sort(x), collapse = " + "))
      pairwise_summary <- aggregate(H ~ pair_id, data = pairwise_interactions, FUN = mean)
      pairwise_summary$Feature1 <- gsub(".*\\+ | \\s", "", pairwise_summary$pair_id)
      pairwise_summary$Feature2 <- gsub("\\+.*|\\s", "", pairwise_summary$pair_id)
      
      #### Extract the N best one ####
      top4_pairs <- head(pairwise_summary[order(-pairwise_summary$H), c(3,4,2)], 4)
    }
    else{top4_pairs <- Selected.biplots}
    
    #### Calculation of the Partial dependance biplots #### 
    print("Partial dependence (2-ways) calculation.")
    pdp_list <- list()
    Plot_list <- list()
    for (i in 1:nrow(top4_pairs)) {
      pd <- pdp::partial(
        FT[[Param.clim]],
        pred.var = c(top4_pairs[i,1], top4_pairs[i,2]),
        train = DB,
        n.trees = Ntrees,
        grid.resolution = Resolution, progress = "text")
      
      if(PD.biplot.ggplot == F){
        Plot.i <- pdp::plotPartial(pd, levelplot = TRUE,
                                   xlab = gsub("_6Me", "'", gsub("f\\.|_5Me", "", top4_pairs[i,1])),
                                   ylab = gsub("_6Me", "'", gsub("f\\.|_5Me", "", top4_pairs[i,2])))
        
        Plot_list[[i]] <- Plot.i
      }
      
      names(pd)[1] <- "x"
      names(pd)[2] <- "y"
      pd$Feature1 <- top4_pairs[i,1]
      pd$Feature2 <- top4_pairs[i,2]
      pd$pair_id <- paste(pd$Feature1, pd$Feature2, sep = ":")
      pdp_list[[i]] <- pd
    }
    
    #### Version ggplot ####
    if(PD.biplot.ggplot == T){
      library(ggplot2); library(patchwork)
      pdp_all <- bind_rows(pdp_list)
      
      Plot_list2 <- list()
      for(i in 1:length(pdp_list)){
        A <- pdp_list[[i]]
        pp <- ggplot(A, aes(x = x*100, y = y*100, fill = yhat))+ 
          geom_raster()+
          scale_fill_viridis_c(name = "y", guide = guide_colorbar(ticks.colour = "black", frame.colour = "black"))+
          xlab(paste(gsub("_6Me", "'", gsub("f\\.|_5Me", "", unique(A$Feature1))), "(%)"))+
          ylab(paste(gsub("_6Me", "'", gsub("f\\.|_5Me", "", unique(A$Feature2))), "(%)"))+
          coord_cartesian(expand = F) +
          theme(panel.background = element_rect(fill = NA, colour = "black", linewidth = 1),
                panel.border = element_rect(fill = NA, colour = "black", linewidth = 1),
                axis.ticks = element_line(colour = "black", linewidth = .5),
                legend.key.width = unit(0.3, "cm"), legend.background = element_blank(), plot.background = element_blank(),
                axis.ticks.length = unit(4, "pt"), legend.key = element_rect(colour = "black"),
                axis.title = element_text(size = 13),
                legend.margin = ggplot2::margin(0, 0, 0, 0),
                legend.box.margin = ggplot2::margin(0, -5, 0, 0),
                panel.grid = element_blank())
        Plot_list2[[i]] <- pp
      }
      
    }
    
    #### Version Lattice ####
    if(PD.biplot.ggplot == F){
      library(grid)
      library(gridExtra)
      lattice_to_grob <- function(lattice_plot) {grid.newpage(); grid.arrange(lattice_plot); grob <- grid.grab(); return(grob)}
      grobs_pdp <- lapply(Plot_list, lattice_to_grob)
      plots <- wrap_plots(grobs_pdp)
      Pfull <- PD2 /((plots[[1]] + plots[[2]])/ (plots[[3]] + plots[[4]])) + plot_layout(heights = c(Rel.Height.interac.plot, 100 - Rel.Height.interac.plot))
      Pfull <- PD2 | (plots[[1]] / plots[[2]] / plots[[3]] / plots[[4]]) + plot_layout(widths = c(Rel.Height.interac.plot, 100 - Rel.Height.interac.plot))
    }
    
    #### Merge all plots (patchwork) ####
    # P.biplot <- Plot_list2[[1]] / Plot_list2[[2]] / Plot_list2[[3]] / Plot_list2[[4]]
    P.biplot <- wrap_plots(Plot_list2, ncol = 1)
    Pfull <- (PD2 | (P.biplot)) + plot_layout(widths = c(Rel.Height.interac.plot, 100 - Rel.Height.interac.plot))
  }
  else{Pfull <- PD2}
  
  #### Export plots ####
  if(is.null(Save.plot) == F){ggsave(filename = Save.plot, Pfull, width = W*0.026458333, height = H*0.026458333, units = "cm")}
  if(is.null(Save.Rds) == F){saveRDS(Pfull, Save.Rds)}
  print(Pfull) 
  return(Pfull)}

FT.core <- function(MCore, MAge, Model.WAPLS = NULL, Model.MAT = NULL, Model.RF = NULL, Model.BRT = NULL,
                    Only.fit = F, LakeName, Select.clim, Fit.val, 
                    Ecartype.curve, Model.param.show, Displot = T, Verbose = T, GDGT = F, GDGT.model = NULL,
                    Zone.Clim.span = NULL, Zone.Temp, Save.path, Save.tab, Save.plot = NULL, Save.RDS = F, H = NULL, W = NULL){
  #### Init param ####
  if(missing(Save.tab)){Save.tab = T}
  if(missing(Zone.Temp)){Zone.Temp = rep("U", length(Zone.Clim.span)/2)}
  if(missing(Select.clim)){Select.clim = NULL}
  if(missing(Save.path)){Save.tab = F; Save.path = NULL}
  if(missing(Zone.Clim.span)){Zone.OK = F}
  if(missing(Model.param.show)){Model.param.show = F}
  if(missing(LakeName)){LakeName = "Lake"}
  if(missing(Fit.val)){Fit.val = 0}
  if(missing(Ecartype.curve)){Ecartype.curve = c(F,F,F,F)}
  if(missing(MAge)){MAge = paste(LakeName, seq(1:nrow(MCore)), sep = "_")}
  
  #### Select le model type ####
  Keep.WAPLS <- deparse(substitute(Model.WAPLS))
  Keep.MAT <- deparse(substitute(Model.MAT))
  Keep.RF <- deparse(substitute(Model.RF))
  Keep.BRT <- deparse(substitute(Model.BRT))
  
  if(is.null(Model.BRT) == F){if(any(names(Model.BRT) %in% "Settings") == T){Model.BRT <- Model.BRT[!names(Model.BRT) %in% "Settings"]}}
  if(is.null(Model.RF) == F){if(any(names(Model.RF) %in% "Settings") == T){Model.RF <- Model.RF[!names(Model.RF) %in% "Settings"]}}
  
  if(is.null(Model.WAPLS)== F){Model.type <- Model.WAPLS}
  if(is.null(Model.MAT)== F){Model.type <- Model.MAT}
  if(is.null(Model.RF)== F){Model.type <- Model.RF}
  if(is.null(Model.BRT)== F){Model.type <- Model.BRT}
  
  #### Save plots ####
  if(is.null(Save.plot) == F & Displot == T){
    Path.to.create <- gsub("(.*/).*\\.pdf.*","\\1", Save.plot)
    dir.create(file.path(Path.to.create), showWarnings = FALSE)
    if(is.null(W) == F & is.null(H) == F){
      pdf(file = Save.plot, width = W*0.01041666666667, height = H*0.01041666666667)}
    else{pdf(file = Save.plot)}}
  
  #### Select param clim ####
  if(is.null(Select.clim) == F){
    Select.clim <- c(Select.clim, "Best.Param")
    Model.type <- Model.type[names(Model.type) %in% Select.clim]
    Model.type$Best.Param <- Model.type$Best.Param[row.names(Model.type$Best.Param) %in% Select.clim,]
    
    if(is.null(Model.BRT) == F){
      Model.BRT <- Model.BRT[names(Model.BRT) %in% Select.clim]
      print(Model.BRT)
      Model.BRT$Best.Param <- Model.BRT$Best.Param[row.names(Model.BRT$Best.Param) %in% Select.clim,]
    }
    
    if(is.null(Model.MAT) == F){
      Model.MAT <- Model.MAT[names(Model.MAT) %in% Select.clim]
      Model.MAT$Best.Param <- Model.MAT$Best.Param[row.names(Model.MAT$Best.Param) %in% Select.clim,]
    }
    
    if(is.null(Model.WAPLS) == F){
      Model.WAPLS <- Model.WAPLS[names(Model.WAPLS) %in% Select.clim]
      Model.WAPLS$Best.Param <- Model.WAPLS$Best.Param[row.names(Model.WAPLS$Best.Param) %in% Select.clim,]
    }
    
    if(is.null(Model.RF) == F){
      Model.RF <- Model.RF[names(Model.RF) %in% Select.clim]
      Model.RF$Best.Param <- Model.RF$Best.Param[row.names(Model.RF$Best.Param) %in% Select.clim,]
    }
  }
  
  #### Graphical settings ####
  Zone.Temp <- rep(Zone.Temp, each=2)
  if(is.null(Zone.Clim.span) == T | length(Zone.Clim.span) != length(Zone.Temp)){
    if(Displot == T){print("Something is wrong with the climate zones. Please check.")}
    Zone.OK = F}
  else{Zone.OK = T}
  Tailleplot <-length(Model.type)-1
  if (Tailleplot <= 3){par(mfrow = c(1,Tailleplot))}
  if (Tailleplot == 4){par(mfrow = c(2,2))}
  if (Tailleplot >= 5 & Tailleplot <= 6){par(mfrow = c(2,3))}
  if (Tailleplot >= 7 & Tailleplot <= 9){par(mfrow = c(3,3))}
  Mmodel <- data.frame(Age = MAge)
  MModel.MAT <- data.frame(Age = MAge)
  MModel.RF <- data.frame(Age = MAge)
  MModel.BRT <- data.frame(Age = MAge)
  M.errors.WAPLS <- data.frame(Age = MAge)
  M.errors.MAT <- data.frame(Age = MAge) 
  M.errors.RF <- data.frame(Age = MAge)
  M.errors.BRT <- data.frame(Age = MAge) 
  Full.MAT.RDS <- list()
  Full.WAPLS.RDS <- list()
  Full.RF.RDS <- list()
  Full.BRT.RDS <- list()
  
  #### Loop on the climat param ####
  if(Verbose == F){
    library(lubridate)
    pb = txtProgressBar(min = 1, max = (length(Model.type)-1), width = 40, initial = 0,  style = 3) 
    init <- numeric((length(Model.type)-1))
    end <- numeric((length(Model.type)-1))
  }
  
  print(paste("Prediction for ", LakeName, " with the following models :", Keep.WAPLS, ", ", Keep.MAT, ", ", Keep.BRT, ", ",  Keep.RF, ".", sep = ""))
  for (i in 1:(length(Model.type)-1)){
    if(Verbose == F){init[i] <- Sys.time()}
    LabParamlim <- as.character(gsub("\\p{P}","", deparse(names(Model.type)[i]), perl = TRUE ))
    #### WAPLS ####
    if(is.null(Model.WAPLS) == F){
      NComp.WAPLS = Model.WAPLS$Best.Param[[3]][i]
      if(NComp.WAPLS < 2){NComp.WAPLS <- 2}
      if(Verbose == T){print(paste(round(i/(length(Model.WAPLS)), digits = 2)*100, "% done. The ", LabParamlim, " is modelling with the WAPLS and ", NComp.WAPLS, " parameters.", sep = ""))}
      
      if(mean(rowSums(Model.WAPLS[[i]]$y), na.rm = T) > 1.5){
        MCore.WAPLS <- sqrt(MCore)
        print("Sqrt() transformation of the past data.")}
      else{MCore.WAPLS <- MCore}
      
      Cor.WAPLS = predict(Model.WAPLS[[i]], MCore.WAPLS, npls = NComp.WAPLS, sse = T, nboot = 1000, verbose = F)
      Mmodel[i+1] <- cbind(Cor.WAPLS$fit[,NComp.WAPLS])
      colnames(Mmodel)[i+1] <- LabParamlim
      M.errors.WAPLS[i+1] <- cbind(Cor.WAPLS$SEP.boot[,NComp.WAPLS])
      colnames(M.errors.WAPLS)[i+1] <- LabParamlim
      Full.WAPLS.RDS[[i]] <- Cor.WAPLS
      names(Full.WAPLS.RDS)[[i]] <- LabParamlim}
    
    #### MAT ####
    if(is.null(Model.MAT) == F){
      NComp.MAT = Model.MAT$Best.Param[[3]][i]
      if(NComp.MAT < 4){NComp.MAT <- 4}
      if(Verbose == T){print(paste("The ", LabParamlim, " is predicted with the MAT and ", NComp.MAT, " analogues.", sep = ""))}
      
      if(mean(rowSums(Model.WAPLS[[i]]$y), na.rm = T) > 1.5){
        MCore.MAP <- sqrt(MCore)
        print("Sqrt() transformation of the past data.")}
      else{MCore.MAP <- MCore}
      
      Cor.MAT = predict(Model.MAT[[i]], MCore.MAP, k = NComp.MAT, sse = T, nboot = 1000, verbose = F)
      MModel.MAT[i+1] <- cbind(Cor.MAT$fit[,2])     # 2 = value-wm (weighted mean), 1 = normal-value
      M.errors.MAT[i+1] <- cbind(Cor.MAT$SEP.boot[,2]) # 2 = value-wm (weighted mean)
      colnames(MModel.MAT)[i+1] <- LabParamlim
      colnames(M.errors.MAT)[i+1] <- LabParamlim
      Full.MAT.RDS[[i]] <- Cor.MAT
      names(Full.MAT.RDS)[[i]] <- LabParamlim}
    
    #### Random forest (RF) ####
    if(is.null(Model.RF) == F){
      if(Verbose == T){print(paste("The ", LabParamlim, " is predicted with the RF.", sep = ""))}
      Cor.RF = predict(Model.RF[[i]], MCore, verbose = F)
      MSE <- Model.RF[[i]]$mse             # Pb dans le mse. Manquant pou Mongolie ?
      RMSE.RF <- sqrt(MSE[length(MSE)])
      # RMSE.RF <- Model.RF[[i]]$Best.Param[row.names(Model.RF[[i]]$Best.Param)==LabParamlim,2]  # Marche pr Mong ms pas Arm
      MModel.RF <- cbind(MModel.RF, Cor.RF)
      colnames(MModel.RF)[i+1] <- LabParamlim
      Full.RF.RDS[[i]] <- Cor.RF
      names(Full.RF.RDS)[[i]] <- LabParamlim}
    
    #### Boosted Regression Tree (BRT) ####
    if(is.null(Model.BRT) == F){
      if(Verbose == T){print(paste("The ", LabParamlim, " is predicted with the BRT.", sep = ""))}
      MCore.i <- MCore[, names(MCore) %in% colnames(Model.BRT[[i]]$data$x.order)] # ATTENTION il manque les taxon < 0.1 pour les BRT
      Cor.BRT <- gbm::predict.gbm(Model.BRT[[i]], MCore.i, n.trees = Model.BRT[[i]]$gbm.call$best.trees, type="response", sse = T, verbose = F)
      # print(Model.BRT[[i]]$cv.fold)
      # print(Cor.BRT)
      RMSE.BRT <- Model.BRT$Best.Param[i,2]
      
      MModel.BRT<- cbind(MModel.BRT, Cor.BRT)
      colnames(MModel.BRT)[i+1] <- LabParamlim
      Full.BRT.RDS[[i]] <- Cor.BRT
      names(Full.BRT.RDS)[[i]] <- LabParamlim
    }
    
    #### Plot résultats graphiques ####
    if(Displot == T){
      #### Val Min / Max ####
      ymin = 0
      ymax = 0
      if(Ecartype.curve[1] == F){
        
        if(is.null(Model.WAPLS) == F){
          ymin = min(Cor.WAPLS$fit[,NComp.WAPLS], na.rm = T)
          ymax = max(Cor.WAPLS$fit[,NComp.WAPLS], na.rm = T)}
        
        if(is.null(Model.MAT) == F & Ecartype.curve[2] == F){
          ymin = min(ymin, Cor.MAT$fit[,2], na.rm = T)
          ymax = max(ymax, Cor.MAT$fit[,2], na.rm = T)}
        
        if(is.null(Model.RF) == F & Ecartype.curve[3] == F){
          ymin = min(ymin, min(Cor.RF, na.rm = T), na.rm = T)
          ymax = max(ymax, max(Cor.RF, na.rm = T), na.rm = T)}
        
        if(is.null(Model.BRT) == F & Ecartype.curve[4] == F){
          ymin = min(ymin, min(Cor.BRT, na.rm = T), na.rm = T)
          ymax = max(ymax, max(Cor.BRT, na.rm = T), na.rm = T)}
        
        fullY <- abs(ymax) - abs(ymin)
        ymax = ymax + 0.05*fullY
      }
      else{
        if(is.null(Model.WAPLS) == F){
          ymin = min(Cor.WAPLS$fit[,NComp.WAPLS] - Cor.WAPLS$SEP.boot[,1], na.rm = T)
          ymax = max(Cor.WAPLS$fit[,NComp.WAPLS] + Cor.WAPLS$SEP.boot[,1], na.rm = T)}
        
        if(is.null(Model.MAT) == F){
          ymin = min(ymin, na.omit(Cor.MAT$fit[,2] - Cor.MAT$SEP.boot[,1]), na.rm = T)
          ymax = max(ymax, na.omit(Cor.MAT$fit[,2] + Cor.MAT$SEP.boot[,1]), na.rm = T)}
        
        if(is.null(Model.RF) == F){
          ymin = min(ymin, min(Cor.RF - RMSE.RF, na.rm = T), na.rm = T)
          ymax = max(ymax, max(Cor.RF + RMSE.RF, na.rm = T), na.rm = T)}
        
        if(is.null(Model.BRT) == F){
          ymin = min(ymin, c(Cor.BRT - RMSE.BRT), na.rm = T)
          ymax = max(ymax, max(Cor.BRT + RMSE.BRT, na.rm = T), na.rm = T)}
        
        fullY <- abs(ymax) - abs(ymin)
        ymax = ymax + 0.05*fullY
      }
      
      #### Plot Mean value ####
      if(is.null(Model.WAPLS) == F & Only.fit == F){Y <- Cor.WAPLS$fit[,NComp.WAPLS]}
      else{Y <- rep(NA, length(MAge))}
      
      plot(MAge, Y, 
           xlim = c(min(MAge),max(MAge)), 
           ylim = c(ymin, ymax), 
           type = "l", 
           ylab = LabParamlim, 
           xlab = "Time (yr cal BP)", 
           col = 1, 
           las = 0, lwd=1, bty="n")
      
      #### Legend ####
      if(Model.param.show == T){
        fullT <- abs(min(MAge)) + abs(max(MAge))
        x1 = 0.3*fullT
        x2 = 0.4*fullT
        x4 = 0.55*fullT
        x5 = 0.65*fullT
        
        ymax.lab1 <- ymax 
        ymax.lab2 <- ymax - 0.05*ymax
        
        #### Legend WAPLS ####
        if(is.null(Model.WAPLS) == F){
          mylabel1 = Keep.WAPLS
          mylabel2 = bquote(npls == .(Model.WAPLS[[1]][["npls"]]) ~ "," ~
                              k == .(Model.WAPLS[[length(Model.WAPLS)]][i,3]) ~ "," ~
                              italic(R)^2 == .(format(Model.WAPLS[[length(Model.WAPLS)]][i,4], digits = 2)) ~ "," ~
                              RMSE == .(format(Model.WAPLS[[length(Model.WAPLS)]][i,5], digits = 2)))
          
          text(x = x1, y = ymax.lab1, labels = mylabel1, font = 2, cex = 0.8, pos = 1)
          text(x = x2, y = ymax.lab1, labels = mylabel2, cex = 0.8, pos = 1)
        }
        
        #### Legend MAT ####
        if(is.null(Model.MAT) == F){
          mylabel1b = Keep.MAT
          mylabel3b = bquote(k == .(Model.MAT[[length(Model.MAT)]][i,3]) ~ "," ~
                               italic(R)^2 == .(format(Model.MAT[[length(Model.MAT)]][i,4], digits = 2)) ~ "," ~
                               RMSE == .(format(Model.MAT[[length(Model.MAT)]][i,5], digits = 2)))
          
          
          text(x = x1, y = ymax.lab2, labels = mylabel1b, col = "royalblue", font = 2, cex = 0.8)
          text(x = x2, y = ymax.lab2, labels = mylabel3b, cex = 0.8)
        }
        
        #### Legend RF ####
        if(is.null(Model.RF) == F){
          mylabel1b = Keep.RF
          mylabel2b = bquote(#Nb.tree == .(Model.RF[[i]][["call"]][["ntree"]]) ~ "," ~
            italic(R)^2 == .(format(Model.RF[[length(Model.RF)]][i,1], digits = 2)) ~ "," ~
              RMSE == .(format(Model.RF[[length(Model.RF)]][i,2], digits = 2)))
          
          
          text(x = x4, y = ymax.lab2, labels = mylabel1b, col = "darkorange", font = 2, cex = 0.8, pos = 1)
          text(x = x5, y = ymax.lab2, labels = mylabel2b, cex = 0.8, pos = 1)
        }
        
        
        #### Legend BRT ####
        if(is.null(Model.BRT) == F){
          mylabel1b = Keep.BRT
          mylabel2b = bquote(Nb.tree == .(Model.BRT[[i]][["call"]][["ntree"]]) ~ "," ~
                               italic(R)^2 == .(format(Model.BRT[[length(Model.BRT)]][i,1], digits = 2)) ~ "," ~
                               RMSE == .(format(Model.BRT[[length(Model.BRT)]][i,2], digits = 2)))
          
          
          text(x = x4, y = ymax.lab1, labels = mylabel1b, col = "darkgreen", font = 2, cex = 0.8, pos = 1)
          text(x = x5, y = ymax.lab1, labels = mylabel2b, cex = 0.8, pos = 1)
        }
      }
      
      #### Plot Model MAT add ####
      if (is.null(Model.MAT) == F & Only.fit == F){
        lines(MAge, Cor.MAT$fit[,2], col = "royalblue", lwd=1, las=0)}
      
      #### Plot Model RF add ####
      if(is.null(Model.RF) == F & Only.fit == F){
        lines(MModel.RF[[1]], Cor.RF, col = "darkorange", lwd=1, las=0)}
      
      #### Plot Model BRT add ####
      if(is.null(Model.BRT) == F & Only.fit == F){
        lines(MModel.BRT[[1]], Cor.BRT, col = "darkgreen", lwd=1, las=0)}
      
      #### Plot fitting ####
      if(Fit.val > 0){
        if (is.null(Model.WAPLS) == F){
          Curve.fit = lowess(Cor.WAPLS$fit[,NComp.WAPLS], f = Fit.val)
          lines(MAge, Curve.fit$y, col=1, lwd=2)}
        if (is.null(Model.MAT) == F){
          Curve.fit.MAT = lowess(Cor.MAT$fit[,2], f = Fit.val)
          lines(MAge, Curve.fit.MAT$y, col= "royalblue", lwd=2)}
        if (is.null(Model.RF) == F){
          Curve.fit.MAT = lowess(Cor.RF, f = Fit.val)
          lines(MAge, Curve.fit.MAT$y, col = "darkorange", lwd=2)}
        if (is.null(Model.BRT) == F){
          Curve.fit.MAT = lowess(Cor.BRT, f = Fit.val)
          lines(MAge, Curve.fit.MAT$y, col = "darkgreen", lwd=2)}
      }
      
      #### Interval WAPLS ####
      if (Ecartype.curve[1] == T & is.null(Model.WAPLS) == F){
        lines(MAge, Cor.WAPLS$fit[,NComp.WAPLS] + Cor.WAPLS$SEP.boot[,1], lwd=.4, lty = "dashed")
        lines(MAge, Cor.WAPLS$fit[,NComp.WAPLS] - Cor.WAPLS$SEP.boot[,1], lwd=.4, lty = "dashed")
      }
      
      #### Interval MAT ####
      if (Ecartype.curve[2] == T & is.null(Model.MAT) == F){
        lines(MAge, Cor.MAT$fit[,2] + Cor.MAT$SEP.boot[,1], lwd=.4, col = "royalblue", lty = "dashed")
        lines(MAge, Cor.MAT$fit[,2] - Cor.MAT$SEP.boot[,1], lwd=.4, col = "royalblue", lty = "dashed")
      }
      
      #### Interval RF ####
      if (Ecartype.curve[3] == T & is.null(Model.RF) == F){
        lines(MAge, Cor.RF + RMSE.RF, lwd=.4, col = "darkorange", lty = "dashed")
        lines(MAge, Cor.RF - RMSE.RF, lwd=.4, col = "darkorange", lty = "dashed")
      }
      
      #### Interval BRT ####
      if (Ecartype.curve[4] == T & is.null(Model.BRT) == F){
        lines(MAge, Cor.BRT + RMSE.BRT, lwd=.4, col = "darkgreen", lty = "dashed")
        lines(MAge, Cor.BRT - RMSE.BRT, lwd=.4, col = "darkgreen", lty = "dashed")
      }
      
      #### Plot climate zones ####
      if (Zone.OK == T){
        for(j in 1:length(Zone.Clim.span)){
          if(as.logical(j%%2) == T){        # seulement les j impairs
            a <- which(MAge>Zone.Clim.span[j])
            b <- which(MAge>Zone.Clim.span[j+1])
            #Ymax <- max(Cor.WAPLS$fit[a[1]:b[1],NComp] + Cor.WAPLS$SEP.boot[a[1]:b[1],NComp])
            #Ymin <- min(Cor.WAPLS$fit[a[1]:b[1],NComp] - Cor.WAPLS$SEP.boot[a[1]:b[1],NComp])
            chaud = rgb(1, 0, 0, 0.08)
            froid = rgb(0, 0, 1, 0.08)
            unknow = rgb(0.3, 0.3, 0.3, 0.08)
            if(Zone.Temp[j]=="C"){colTemp <- froid}
            if(Zone.Temp[j]=="W"){colTemp <- chaud}
            if(Zone.Temp[j]=="U"){colTemp <- unknow}
            polygon(c(Zone.Clim.span[j],Zone.Clim.span[j+1], Zone.Clim.span[j+1],Zone.Clim.span[j]), c(ymin, ymin, ymax, ymax), border = NA, col = colTemp)
          }}}
    }
    if(Verbose == F){
      end[i] <- Sys.time()
      setTxtProgressBar(pb, i)
      time <- round(seconds_to_period(sum(end - init)), 0)
      est <- (length(Model.type)-1) * (mean(end[end != 0] - init[init != 0])) - time
      remainining <- round(seconds_to_period(est), 0)
      cat(paste(" // Execution time:", time,
                " // Estimated time remaining:", remainining), "")}
    
  }
  
  if(Verbose == F){close(pb);library(beepr)} 
  
  #### Save / export data ####
  row.names(Mmodel) <- row.names(MCore)
  par(mfrow = c(1,1))
  if(Save.tab == T){
    Path.to.create.csv <- gsub("(.*/).*\\.csv.*","\\1", Save.path)
    dir.create(file.path(Path.to.create.csv), showWarnings = FALSE)
    
    if(is.null(Model.WAPLS) == F){
      #### Save WAPLS ####
      Save.Model.WAPLS <- gsub("\\.", "_", Keep.WAPLS)
      add.to.path <- paste("_", Save.Model.WAPLS, ".csv", sep = "")
      add.to.path.error <- paste("_SEP_", Save.Model.WAPLS, ".csv", sep = "")
      Save.path1 <- gsub("\\.csv", add.to.path, Save.path)
      Save.path.error <- gsub("\\.csv", add.to.path.error, Save.path)
      write.table(Mmodel, file = Save.path1, row.names=T, col.names=NA, sep=",", dec = ".")
      write.table(M.errors.WAPLS, file = Save.path.error, row.names=T, col.names=NA, sep=",", dec = ".")
    }}
  
  if(is.null(Model.MAT) == F){
    #### Save MAT ####
    if(Save.tab == T){
      Save.Model.WAPLS <- gsub("\\.", "_", Keep.MAT)
      add.to.path <- paste("_", Save.Model.WAPLS, ".csv", sep = "")
      add.to.path.error <- paste("_SEP_", Save.Model.WAPLS, ".csv", sep = "")
      Save.path2 <- gsub("\\.csv", add.to.path, Save.path)
      Save.path2.error <- gsub("\\.csv", add.to.path.error, Save.path)
      write.table(MModel.MAT, file = Save.path2, row.names=T, col.names=NA, sep=",", dec = ".")
      write.table(M.errors.MAT, file = Save.path2.error, row.names=T, col.names=NA, sep=",", dec = ".")
    }
    
    #### Add MAT to function return ####
    Mmodel = list(Mmodel, MModel.MAT, M.errors.WAPLS, M.errors.MAT)
    Save.DB.name <- gsub(".*\\.","", Keep.WAPLS)
    labtot <- c(Keep.WAPLS, Keep.MAT, paste("SEP.WAPLS", Save.DB.name, sep = "."), paste("SEP.MAT", Save.DB.name, sep = "."))
    names(Mmodel) <- labtot}
  
  if(is.null(Model.RF) == F){
    #### Save RF ####
    if(Save.tab == T){
      Save.Model.WAPLS <- gsub("\\.", "_", Keep.RF)
      add.to.path <- paste("_", Save.Model.WAPLS, ".csv", sep = "")
      Save.path2 <- gsub("\\.csv", add.to.path, Save.path)
      write.table(MModel.RF, file = Save.path2, row.names=T, col.names=NA, sep=",", dec = ".")
    }
    
    #### Add RF to function return ####
    Mmodel <- append(Mmodel, list(MModel.RF))
    names(Mmodel)[length(Mmodel)] <- Keep.RF
  }
  
  if(is.null(Model.BRT) == F){
    #### Save BRT ####
    if(Save.tab == T){
      # print(Keep.BRT)
      Save.Model.BRT <- gsub("\\.", "_", Keep.BRT)
      add.to.path <- paste("_", Save.Model.BRT, ".csv", sep = "")
      Save.path2 <- gsub("\\.csv", add.to.path, Save.path)
      write.table(MModel.BRT, file = Save.path2, row.names=T, col.names = NA, sep=",", dec = ".")
    }
    
    #### Add BRT to function return ####
    Mmodel <- append(Mmodel, list(MModel.BRT))
    names(Mmodel)[length(Mmodel)] <- Keep.BRT
  }
  
  Total.model <- list(WAPLS = Full.WAPLS.RDS, MAT = Full.MAT.RDS, BRT = Full.BRT.RDS, RF = Full.RF.RDS)
  
  #### Save format RDS ####
  if(Save.RDS == T & is.null(Save.path) == F){
    if(GDGT == F & exists("Save.DB.name") == F){Save.DB.name <- gsub(".*\\.","", deparse(substitute(Model.WAPLS)))}
    if(GDGT == T){
      if(is.null(Model.BRT) == F){Save.DB.name <- gsub(".*\\.","", Keep.BRT)}
      if(is.null(Model.WAPLS) == F){Save.DB.name <- gsub(".*\\.","", Keep.WAPLS)}
      if(is.null(Model.MAT) == F){Save.DB.name <- gsub(".*\\.","", Keep.MAT)}
      if(is.null(Model.RF) == F){Save.DB.name <- gsub(".*\\.","", Keep.RF)}
      
      if(is.null(GDGT.model) == F){Save.DB.name <- paste(GDGT.model, Save.DB.name, sep = "_")} 
    }
    
    Save.path.RDS <- paste(gsub("\\.csv", paste("_", Save.DB.name, sep = ""), Save.path), ".Rds", sep = "")
    Save.path.RDS.full <- paste(gsub("\\.csv", paste("_", Save.DB.name, "_full", sep = ""), Save.path), ".Rds", sep = "")
    Path.to.create2 <- gsub("(.*/).*\\.Rds.*","\\1", Save.path.RDS)
    dir.create(file.path(Path.to.create2), showWarnings = F)
    
    saveRDS(Total.model, Save.path.RDS.full)
    saveRDS(Mmodel, Save.path.RDS)}
  
  #### End ####
  if(is.null(Save.plot) == F){dev.off()}
  if(GDGT == F){return(Total.model)}
  else{return(Mmodel)}
}

Combine.ML.cluster <- function(Cluster.prediction, List.models, Model.lab, GDGT.paleo, Plot.y = "Age", Param.clim = "MAAT", 
                               Highlight.combined = F, Save.path = NULL, Method = "BRT", return.plot = F, Panel.annot = NULL, Time.res = NULL,
                               Compare.curve = NULL, Cluster.prob = "Both", Time.lim = NULL, Surf.val = NULL, Dot.size = 1.5, Time.in.k = F,
                               Core.name = NULL, Plot.y.lab = Plot.y, Show.proba = T, Facet = T, Only.best = T, H = 900, W = 500, Save.plot = NULL){
  #### Cluster predictions ####
  Br.GDGT.paleo <- GDGT.paleo[grepl("f.I", names(GDGT.paleo)) & !grepl("_7Me", names(GDGT.paleo))]
  Br.GDGT.paleo <- data.frame(t(Br.GDGT.paleo))
  Br.GDGT.paleo <- apply(Br.GDGT.paleo, 2, MESS::round_percent)
  Br.GDGT.paleo <- data.frame(t(Br.GDGT.paleo/100))
  RF_class <- stats::predict(Cluster.prediction, Br.GDGT.paleo)
  RF_class_prob <- stats::predict(Cluster.prediction, Br.GDGT.paleo, type = "prob")
  Br.GDGT.paleo$Pred.cluster <- RF_class
  Br.GDGT.paleo$Plot.y <- GDGT.paleo[[Plot.y]]
  
  #### Matrix full ####
  List.models <- Map(function(df, Model){df$Model <- Model; return(df)}, List.models, Model.lab)
  M <- do.call(rbind, List.models)
  All.param <- setdiff(names(M), c(Plot.y, "Model"))
  M$Pred.cluster <- Br.GDGT.paleo$Pred.cluster[match(M[[Plot.y]], Br.GDGT.paleo$Plot.y)]
  M$Model <- factor(M$Model, ordered = T, levels = unique(M$Model))
  
  #### Matrix full (weighted) ####
  List.models[[1]] <- List.models[[1]][c(Plot.y, Param.clim)]
  Mw <- cbind(List.models[[1]], MAAT.karid = List.models[[2]][[Param.clim]], MAAT.kwet = List.models[[3]][[Param.clim]], RF_class_prob)
  names(Mw)[c(1:2)] <- c("Plot.y", "Param.clim")
  Mw$Combine.weighted <- Mw$MAAT.kwet*Mw$`K-cold/wet` + Mw$MAAT.karid*Mw$`K-warm/arid`
  Mw$Pred.cluster <- ifelse(Mw$`K-warm/arid` >= 0.5, "K-warm/arid", "K-cold/wet")
  Mw$Model <- "Combine-Weighted"
  Mw$Param.clim <- Mw$Combine.weighted
  Keep <- c(Plot.y, Param.clim, "Model", "Pred.cluster")
  M <- M[Keep]
  names(M)[c(1:2)] <- c("Plot.y", "Param.clim")
  M <- dplyr::full_join(M, Mw[c(1,2,9,8)], by = join_by(Plot.y, Param.clim, Model, Pred.cluster))
  
  if(Only.best == T){
    M <- M[M$Model  %in% c("ACADB", "Combine-Weighted"),]  
  }
  M$Model <- factor(M$Model, ordered = T, levels = unique(M$Model))
  
  RF_class_prob <- data.frame(RF_class_prob)
  RF_class_prob$Plot.y <- GDGT.paleo[[Plot.y]]
  
  #### Graphical settings ####
  My_colors <- c("Combined" = "grey20", "Combine-Weighted" = "darkred", 
                 "ACADB" = "bisque3", "K-cold/wet" = "royalblue", "K-warm/arid" = "darkorange",
                 "MAAT_soil_Naaf" = "darkgreen", "MAAT_LSun" = "#6b00b2ff", "MAF_MSosa" = "#6b00b2ff", "MAF_meth_Raberg" = "darkgreen", "MAF_full_Raberg" = "aquamarine2",
                 "MAAT_mr_DJ" = "#d1b336ff", "MAAT_DJ_5Me" = "darkolivegreen3", "MAAT_NMSDB_mr5" = "aquamarine2")
  
  My_labs <- c("Combined" = "Combined", "Combine-Weighted" = "BRT(combined)", 
               "MAAT_soil_Naaf" = "MBT'5Me (Naafs et al., 2017)", "MAAT_LSun" = "MBT/CBT lake (Sun et al., 2011)",
               "ACADB" = paste(Method, "(ACADB)"), 
               "K-cold/wet" = paste(Method, "(K-cold/wet)"),
               "K-warm/arid" = paste(Method, "(K-warm/arid)"),
               "MAAT_mr_DJ" = "MR (De Jonge et al., 2014)", "MAAT_DJ_5Me" = "MBT'5Me (De Jonge et al., 2014)", "MAAT_NMSDB_mr5" = "MR mong.")
  
  if(Facet == T){My_facet <- facet_geochem_grid(vars(Model))}
  else{My_facet <- NULL; H <- H/2}
  
  if(is.null(Plot.y.lab) == F){
    if(is.null(Compare.curve) == F){
      Age.lab.2 <- Plot.y.lab; Age.lab.1 <- NULL}
    else{Age.lab.1 <- Plot.y.lab}
    
  }
  else{
    if(is.null(Compare.curve) == F){
      Age.lab.2 <- Plot.y; Age.lab.1 <- NULL}
    else{Age.lab.1 <- Plot.y}
  }
  
  if(Param.clim %in% c("MAAT", "MAF")){
    Clim.lab.1 <- paste(Param.clim, " (°C)\n", Method, sep = "")
    Clim.lab.2 <- paste(Param.clim, " (°C)\ncomparison", sep = "")
  }
  else{
    Clim.lab.1 <- paste(Param.clim, "\n", Method, sep = "")
    Clim.lab.2 <- paste(Param.clim, "\ncomparison", sep = "")
    # Clim.lab.1 <- Param.clim; Clim.lab.2 <- Param.clim
  }
  
  if(is.null(Surf.val) == F){
    Surf.line <- geom_hline(yintercept = Surf.val, linetype = "dotdash", linewidth = 0.55, color = "black", alpha = 0.55)
  }
  else{Surf.line <- NULL}
  
  if(is.null(Core.name) == F){
    My_title <- ggtitle(Core.name)
  }
  else{My_title <- NULL}
  
  if(Highlight.combined == T){
    Double.line <- geom_line(data = Mw, aes(x = Plot.y, y = Combine.weighted, group = Model, color = Model), linewidth = .8)}
  else{Double.line <- NULL}
  
  if(is.null(Time.lim) == F){Xlim <- xlim(Time.lim)}
  else{Xlim <- NULL}
  
  if(is.null(Plot.y.lab) == T){
    X.title <- element_blank()
  }
  else{X.title <- element_text()}
  
  if(is.null(Panel.annot) == F){
    if(length(Panel.annot) == 1){
      Annot.in.1 <- ggplot2::annotate("text", x = Inf, y = Inf, label = paste("(", Panel.annot, "1)", sep = ""), hjust = 1.1, vjust = 1.5, size = 4.5)
      Annot.in.2 <- ggplot2::annotate("text", x = Inf, y = Inf, label = paste("(", Panel.annot, "2)", sep = ""), hjust = 1.1, vjust = 1.5, size = 4.5)
      Annot.in.3 <- ggplot2::annotate("text", x = Inf, y = Inf, label = paste("(", Panel.annot, "3)", sep = ""), hjust = 1.1, vjust = 1.5, size = 4.5)
      
      if(Show.proba == T){Annot.in.cp <- Annot.in.1; Annot.in.main <- Annot.in.2; Annot.in.compar <- Annot.in.3}
      else{Annot.in.main <- Annot.in.1; Annot.in.compar <- Annot.in.2}
    }
    else{print("A faire !!!!")}
  }
  else{Annot.in.cp <- NULL; Annot.in.main <- NULL; Annot.in.compar <- NULL}
  
  if(is.null(Time.res) == F & is.null(Time.lim) == F){
    if(Time.in.k == T){
      My_time_breaks <- paste(seq(Time.lim[1]/1000, Time.lim[2]/1000, Time.res/1000), "k", sep = "")}
    else{My_time_breaks <- seq(Time.lim[1], Time.lim[2], Time.res)}
    My_scale_time <- scale_x_continuous(breaks = seq(Time.lim[1], Time.lim[2], Time.res), labels = My_time_breaks, limits = Time.lim)}
  else{My_scale_time <- NULL}
  
  #### Comparative curves ####
  if(is.null(Compare.curve) == F){
    Mc <- GDGT.paleo[c(Plot.y, Compare.curve)]
    Mc$'Combine-Weighted' <- Mw$Combine.weighted
    Mc <- melt(Mc, id = Plot.y)
    Ticks.1 <- element_blank(); Text.1 <- element_blank()
    
    Mc$Pred.cluster <- Br.GDGT.paleo$Pred.cluster[match(Mc[[Plot.y]], Br.GDGT.paleo$Plot.y)]
    names(Mc)[c(1:2)] <- c("Plot.y", "Model")
    Mc$Model <- factor(Mc$Model, ordered = T, levels = unique(Mc$Model))
    p.comp <- ggplot(Mc, aes(x = Plot.y, y = value, group = Model))+
      My_facet+ Surf.line+ Xlim+ Annot.in.compar + 
      geom_point(aes(color = Model), show.legend = T, size = Dot.size, shape = 16)+
      # geom_point(aes(color = Pred.cluster), show.legend = T)+
      geom_line(aes(color = Model))+ xlab(Age.lab.2)+ ylab(Clim.lab.2)+
      Double.line +
      My_scale_time +
      # guides(color = guide_legend(override.aes = list(shape = NA)))+
      scale_color_manual(values = My_colors, label = My_labs, name = NULL)
  }
  else{Ticks.1 <- element_line(); Text.1 <- element_text()}
  
  #### Plot (main) ####
  p.main <- ggplot(M, aes(x = Plot.y, y = Param.clim, group = Model))+
    My_facet+ Surf.line+ Xlim+ Annot.in.main +
    geom_point(aes(color = Pred.cluster), shape = 16, size = Dot.size)+
    geom_line(aes(color = Model))+ 
    Double.line+
    My_scale_time +
    
    xlab(Age.lab.1)+ ylab(Clim.lab.1)+
    scale_color_manual(values = My_colors, label = My_labs, name = NULL)+
    theme(axis.text.x = Text.1, axis.ticks.x = Ticks.1)
  
  #### Plot (proba. cluster) ####
  if(Show.proba == T){
    RF_class_prob2 <- RF_class_prob
    if(Cluster.prob == "K-warm/arid"){
      RF_class_prob2$Prob.to.show <- RF_class_prob2$K.warm.arid
      Estim.col <- "darkorange"; My_col_scale <- NULL
      My_area <- geom_area(fill = Estim.col, position = "stack")}
    if(Cluster.prob == "K-cold/wet"){
      RF_class_prob2$Prob.to.show <- RF_class_prob2$K.cold.wet
      Estim.col <- "royalblue"; My_col_scale <- NULL
      My_area <- geom_area(fill = Estim.col, position = "stack")}
    if(Cluster.prob == "Both"){
      RF_class_prob2 <- melt(RF_class_prob2, id = "Plot.y")
      names(RF_class_prob2)[names(RF_class_prob2) == "value"] <- "Prob.to.show"
      My_area <- geom_area(aes(fill = variable), position = "stack", color = NA, alpha = .7)
      My_col <- c("K.warm.arid" = "darkorange",
                  "K.cold.wet" = "royalblue")
      My_col_scale <- scale_fill_manual(values = My_col, drop = T)
    }
    
    RF_class_prob2$Prob.to.show <- round(RF_class_prob2$Prob.to.show*100, digits = 0)
    p.prob <- ggplot(RF_class_prob2, aes(x = Plot.y, y = Prob.to.show))+
      My_area+ My_title+ Xlim+ Annot.in.cp +
      My_col_scale+
      scale_y_continuous(limits = c(0,100), breaks = c(0,50,100))+
      xlab(NULL)+ylab("Cluster\nprob.")+
      theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), axis.title.x = element_blank())
    
    p.main <- p.prob / p.main# + plot_layout(heights = c(1, nlevels(M$Model)))
  }
  
  #### Merge plots ####
  if(is.null(Compare.curve) == F){
    p.main <- p.main / p.comp + plot_layout(guides = "collect")
  }
  
  p.main <- p.main&
    theme(panel.background = element_rect(fill = NA, color = "black"), legend.key = element_rect(fill = NA, color = NA),
          panel.grid = element_blank(), axis.title.x = X.title, 
          plot.background = element_blank(),
          plot.margin = unit(c(0,0,0,0), 'pt'),
          legend.position = "bottom")&
    guides(color = guide_legend(nrow = 3))
  
  #### Generalized combined plot ####
  Mexp <- data.frame(List.models[[1]][Plot.y])
  for(i in 1:length(All.param)){
    Clim.i <- All.param[i]
    Mw <- cbind(List.models[[1]], M2 = List.models[[2]][[Clim.i]], M1 = List.models[[3]][[Clim.i]], RF_class_prob)
    
    Mexp[i+1] <- Mw$M1*Mw$K.cold.wet + Mw$M2*Mw$K.warm.arid
    names(Mexp)[i+1] <- Clim.i
  }
  
  # names(Mexp)[! names(Mexp) %in% Plot.y] <- paste(names(Mexp)[! names(Mexp) %in% Plot.y], "_", Method, "-CB", sep = "")
  Mexp2 <- Mexp[Plot.y]
  Mexp2$K.warm.arid <- Mw$K.warm.arid
  Mexp2$K.cold.wet <- Mw$K.cold.wet
  Mexp2$Pred.cluster <- ifelse(Mw$K.warm.arid >= 0.5, "K-warm/arid", "K-cold/wet")
  Mexp <- list(Mexp, Mexp2)
  
  if(is.null(Save.path) == F){saveRDS(Mexp, Save.path)}
  
  #### Export plot ####
  if(is.null(Save.plot) == F){ggsave(filename = Save.plot, p.main, width = W*0.026458333, height = H*0.026458333, units = "cm")}
  if(return.plot == T){return(p.main)}
  if(return.plot == F){return(Mexp)}
  
}

Plot.randomTF <- function(MPsurf, MPpaleo, Mclim, Plot.MAT = F, Plot.WAPLS = F, Plot.RF = F, Plot.BRT = T, Bold = T, Database = NULL, Lake = NULL,
                          BRT.max_trees = 1000, BRT.learning_rate = 0.025, BRT.tree_complexity = 4, BRT.bag_fraction = 0.75, BRT.minobs = 10, Transformation = F,
                          Nb.simul = 99, H = 300, W = 1500, Save.path = NULL, return.plot = F, Save.plot = NULL) {
  #### Settings ####
  library(palaeoSig)
  DB.result <- NULL
  if(is.null(Lake) == T & is.null(Database) == F){print(paste("randomFT() made for", Database))}
  if(is.null(Lake) == F & is.null(Database) == F){print(paste("randomFT() made for", Database, "on lake", Lake))}
  set.seed(123)
  
  if(Transformation == T){MPsurf1 <- sqrt(MPsurf); MPpaleo1 <- sqrt(MPpaleo)}
  else{MPsurf1 <- MPsurf; MPpaleo1 <- MPpaleo}
  
  #### MAT settings ####
  if(Plot.MAT == T){
    rlghr <- randomTF(spp = MPsurf1, 
                      env = Mclim,
                      fos = MPpaleo1,
                      n = Nb.simul, fun = MAT, col = 1, k = 10, lean = F)
    
    PP1 <- autoplot(rlghr) + theme_light() + ggtitle(paste("MAT (", Database, ")", sep = ""))
    
    P95 <- sort(rlghr$sim.ex)[floor(length(rlghr$sim.ex)*0.95)]
    DB.MAT <- data.frame(round(cbind(t(rlghr$EX), P95 = P95, Var.max = rlghr$MAX), 2))
    if(Bold == T){DB.MAT[1,which(rlghr$EX >= round(P95, 2))] <- paste("\\textbf{", DB.MAT[1,which(rlghr$EX >= round(P95, 2))], "}", sep = "")}
    DB.MAT[1,which(rlghr$sig <= 0.01)] <- paste(DB.MAT[1,which(rlghr$sig <= 0.01)], "*", sep = "") # Rehfeld et al., 2016
    DB.MAT[1,which(rlghr$sig <= 0.1)] <- paste(DB.MAT[1,which(rlghr$sig <= 0.1)], "*", sep = "") # Rehfeld et al., 2016
    DB.MAT <- cbind(Database = Database, Model = "MAT", DB.MAT)
  }
  else{PP1 <- NULL; DB.MAT <- NULL}
  
  #### WAPLS settings ####
  if(Plot.WAPLS == T){
    rlghr <- randomTF(spp = MPsurf1, 
                      env = Mclim,
                      fos = MPpaleo1, 
                      n = Nb.simul, fun = WAPLS, col = 1, npls = 5, lean = F)
    
    PP2 <- autoplot(rlghr) + theme_light() + ggtitle(paste("WAPLS (", Database, ")", sep = ""))
    
    P95 <- sort(rlghr$sim.ex)[floor(length(rlghr$sim.ex)*0.95)]
    DB.WAPLS <- data.frame(round(cbind(t(rlghr$EX), P95 = P95, Var.max = rlghr$MAX), 2))
    if(Bold == T){DB.WAPLS[1,which(rlghr$EX >= round(P95, 2))] <- paste("\\textbf{", DB.WAPLS[1,which(rlghr$EX >= round(P95, 2))], "}", sep = "")}
    DB.WAPLS[1,which(rlghr$sig <= 0.01)] <- paste(DB.WAPLS[1,which(rlghr$sig <= 0.01)], "*", sep = "")
    DB.WAPLS[1,which(rlghr$sig <= 0.1)] <- paste(DB.WAPLS[1,which(rlghr$sig <= 0.1)], "*", sep = "")
    DB.WAPLS <- cbind(Database = Database, Model = "WAPLS", DB.WAPLS)
  }
  else{PP2 <- NULL; DB.WAPLS <- NULL}
  
  #### RF settings ####
  if(Plot.RF == T){
    rlghr <- randomTF(spp = MPsurf, 
                      env = Mclim,
                      fos = MPpaleo, 
                      n = Nb.simul, fun = randomForest, col = 1, ntree = 500, na.action = na.roughfix)
    
    PP3 <- autoplot(rlghr) + theme_light() + ggtitle(paste("RF (", Database, ")", sep = ""))
    P95 <- sort(rlghr$sim.ex)[floor(length(rlghr$sim.ex)*0.95)]
    DB.RF <- data.frame(round(cbind(t(rlghr$EX), P95 = P95, Var.max = rlghr$MAX), 2))
    if(Bold == T){DB.RF[1,which(rlghr$EX >= round(P95, 2))] <- paste("\\textbf{", DB.RF[1,which(rlghr$EX >= round(P95, 2))], "}", sep = "")}
    DB.RF[1,which(rlghr$sig <= 0.01)] <- paste(DB.RF[1,which(rlghr$sig <= 0.01)], "*", sep = "")
    DB.RF[1,which(rlghr$sig <= 0.1)] <- paste(DB.RF[1,which(rlghr$sig <= 0.1)], "*", sep = "")
    DB.RF <- cbind(Database = Database, Model = "RF", DB.RF)
  }
  else{PP3 <- NULL; DB.RF <- NULL}
  
  #### BRT settings ####
  if(Plot.BRT == T){
    rlghr <- randomTF(spp = MPsurf, env = Mclim, fos = MPpaleo,
                      n = Nb.simul, fun = train, col = 1, method = "gbm", bag.fraction = BRT.bag_fraction,
                      tuneGrid = data.frame(
                        n.trees = BRT.max_trees,
                        interaction.depth = BRT.tree_complexity,
                        shrinkage = BRT.learning_rate,
                        n.minobsinnode = BRT.minobs),
                      verbose = F)
    
    PP4 <- autoplot(rlghr) + ggplot2::theme_light() + ggtitle(paste("BRT (", Database, ")", sep = ""))
    
    P95 <- sort(rlghr$sim.ex)[floor(length(rlghr$sim.ex)*0.95)]
    DB.BRT <- data.frame(round(cbind(t(rlghr$EX), P95 = P95, Var.max = rlghr$MAX), 2))
    if(Bold == T){DB.BRT[1,which(rlghr$EX >= round(P95, 2))] <- paste("\\textbf{", DB.BRT[1,which(rlghr$EX >= round(P95, 2))], "}", sep = "")}
    DB.BRT[1,which(rlghr$sig <= 0.01)] <- paste(DB.BRT[1,which(rlghr$sig <= 0.01)], "*", sep = "")
    DB.BRT[1,which(rlghr$sig <= 0.1)] <- paste(DB.BRT[1,which(rlghr$sig <= 0.1)], "*", sep = "")
    DB.BRT <- cbind(Database = Database, Model = "BRT", DB.BRT)
  }
  else{PP4 <- NULL; DB.BRT <- NULL}
  
  #### Export results ####
  DB.result <- rbind(DB.MAT, DB.WAPLS, DB.RF, DB.BRT)
  PP <- PP1 + PP2 + PP3 + PP4
  
  if(is.null(Save.path) == F){
    Path.to.create <- gsub("(.*/).*\\.Rds.*","\\1", Save.path)
    dir.create(file.path(Path.to.create), showWarnings = F)
    saveRDS(DB.result, Save.path)
  }
  if(is.null(Save.plot) == F){
    Path.to.create <- gsub("(.*/).*\\.pdf.*","\\1", Save.plot)
    dir.create(file.path(Path.to.create), showWarnings = F)
    ggsave(file = Save.plot, PP, width = W*0.01041666666667, height = H*0.01041666666667)}
  
  if(return.plot == F){return(DB.result)}
  else{return(PP)}
}

CrossVal.ML <- function(Mclim = NULL, Param.clim = NULL, Mproxy = NULL, Model = c("RF", "BRT"),
                        Return.param = F, Parallelize = F, Nested.CV = T, Inner.CV = F, Extern.CV = F, Self.CV = F, Save.model = NULL, Save.table = NULL,
                        Tuning.extern.CV = F, Tuning.nested.CV = T, K.fold.inner = 10 , K.fold.outer = 5, Mtry = ncol(Mproxy)/3, Manual.tuning.grid = NULL,
                        Ntree = 500, max_trees = 7000, learning_rate = 0.025, tree_complexity = 6, bag_fraction = 0.75, min_obs = 10){
  
  print(paste("CrossVal.ML run for the", Model, "on", substitute(Mproxy), "dataset."))
  tictoc::tic(paste("CrossVal.ML run for the", Model, "on", substitute(Mproxy), "dataset."))
  
  One_run <- function(Param.clim){
    #### Data preparation ####
    library(caret)
    library(gbm)
    library(dismo)
    library(randomForest)
    library(dplyr)
    
    if(Parallelize == T){library(doParallel)}
    data <- as.data.frame(cbind(Mproxy, Mclim[Param.clim]))
    predictors <- names(data)[1:ncol(data)-1]
    formula <- as.formula(paste(Param.clim, "~ ."))
    
    set.seed(123)
    folds <- createFolds(data[[Param.clim]], k = K.fold.outer, returnTrain = T)
    
    #### RF ####
    if(any(Model %in% "RF")){
      #### Grid settlement ####
      rf_nested_results <- data.frame(R2 = numeric(), RMSE = numeric())
      
      if(is.null(Manual.tuning.grid) == T){
        rf_grid <- expand.grid(mtry = c(1, 2, 4, 6, 8, 10, 20, 30, 40))
      }
      else{rf_grid <- Manual.tuning.grid}
      
      
      rf_grid_fixed <- expand.grid(mtry = Mtry)
      if(Nested.CV == T | Inner.CV == T | Extern.CV == T | Self.CV == T){rf_model <- randomForest(formula, data = data, ntree = Ntree, mtry = Mtry, na.action = na.roughfix)}
      
      #### Self estimation (both caret et native) ####
      if(Self.CV == T){
        #### Native self stats #### 
        rf_pred_self <- predict(rf_model, data)
        self_metrics_n <- data.frame(Method = "Self (natif)",
                                     RF_R2 = round(R2(rf_pred_self, data[[Param.clim]]), digits = 2),
                                     RF_RMSE = round(RMSE(rf_pred_self, data[[Param.clim]]), digits = 2))
        
        if(Return.param == T){self_metrics_n <- cbind(self_metrics_n, data.frame(RF_ntree = rf_model$ntree, M_try = rf_model$mtry))}
        
        #### Caret self stats #### 
        rf_self <- train(formula, data = data, method = "rf", trControl = trainControl(method = "none"), tuneGrid = rf_grid_fixed, ntree = Ntree, na.action = na.roughfix)
        rf_pred_self <- predict(rf_self, data)
        
        self_metrics <- data.frame(Method = "Self (caret)",
                                   RF_R2 = round(R2(rf_pred_self, data[[Param.clim]]), digits = 2),
                                   RF_RMSE = round(RMSE(rf_pred_self, data[[Param.clim]]), digits = 2))
        
        if(Return.param == T){self_metrics <- cbind(self_metrics, data.frame(RF_ntree = rf_model$ntree, M_try = rf_model$mtry))}
        Selt_full <- rbind(self_metrics, self_metrics_n)
      }
      else{Selt_full <- NULL}
      
      #### Internal CV (OOB) ####
      if(Inner.CV == T){
        Inner_full <- data.frame(
          Method = "Internal CV (OOB/ k-fold)",
          # RF_R2 = round(rf_model$rsq[which.max(rf_model$rsq)], digits = 2),
          RF_R2 = round(rf_model$rsq[length(rf_model$rsq)], digits = 2),
          RF_RMSE = round(sqrt(mean((data[[Param.clim]] - rf_model$predicted)^2)), digits = 2))
        
        if(Return.param == T){Inner_full <- cbind(Inner_full, data.frame(RF_ntree = rf_model$ntree, M_try = rf_model$mtry))}
      }
      else{Inner_full <- NULL}
      
      #### External CV (caret, k-fold) ####
      if(Extern.CV == T){
        if(Tuning.extern.CV == T){
          rf_grid_1 <- rf_grid
          
          if(Parallelize == T){
            n_cores <- parallel::detectCores() - 1
            cl <- makeCluster(n_cores)
            registerDoParallel(cl)}
        }
        else{rf_grid_1 <- rf_grid_fixed}
        
        ctrl_inner <- trainControl(method = "cv", number = K.fold.inner)
        rf_cv <- train(formula, data = data, method = "rf", trControl = ctrl_inner, tuneGrid = rf_grid_1, ntree = Ntree)
        
        if(Parallelize == T & Tuning.extern.CV == T){stopCluster(cl); registerDoSEQ()}
        
        Extern_full <- data.frame(Method = "External CV (caret)",
                                  RF_R2 = signif(rf_cv$results$Rsquared[which.min(rf_cv$results$RMSE)], digits = 2),
                                  RF_RMSE = signif(rf_cv$results$RMSE[which.min(rf_cv$results$RMSE)], digits = 3))
        # RF_R2 = round(max(rf_cv$results$Rsquared), digits = 2),
        # RF_RMSE = round(rf_cv$results$RMSE[which.max(rf_cv$results$Rsquared)], digits = 2))
        
        if(Return.param == T){Extern_full <- cbind(Extern_full, data.frame(RF_ntree = rf_cv$finalModel$ntree, M_try = rf_cv$finalModel$mtry))}
      }
      else{Extern_full <- NULL}
      
      #### Nested CV ####
      if(Nested.CV == T){
        #### Parallelize ####
        if(Parallelize == T){
          n_cores <- parallel::detectCores() - 1
          cl <- makeCluster(n_cores)
          registerDoParallel(cl)}
        
        #### Grid settings ####
        if(Tuning.nested.CV == T){rf_grid_2 <- rf_grid}
        else{rf_grid_2 <- rf_grid_fixed}
        
        #### Outer k-fold loop ####
        for (i in 1:K.fold.outer) {
          train_idx <- folds[[i]]
          train_data <- data[train_idx, ]
          test_data <- data[-train_idx, ]
          ctrl_inner <- trainControl(method = "cv", number = K.fold.inner)
          rf_mod <- train(formula, data = train_data, method = "rf", tuneGrid = rf_grid_2, trControl = ctrl_inner)
          rf_pred <- predict(rf_mod, test_data)
          rf_nested_results <- rbind(rf_nested_results, data.frame(R2 = R2(rf_pred, test_data[[Param.clim]]), RMSE = RMSE(rf_pred, test_data[[Param.clim]])))
          if(Parallelize == T){stopCluster(cl); registerDoSEQ()}
        }
        
        #### Final summary table ####
        nested_metrics_tuned <- data.frame(
          Method = "Nested CV (Tuned)",
          RF_R2 = round(mean(rf_nested_results$R2), digits = 2),
          RF_RMSE = round(mean(rf_nested_results$RMSE), digits = 2))
        
        if(Return.param == T){nested_metrics_tuned <- cbind(nested_metrics_tuned, data.frame(RF_ntree = rf_mod$finalModel$ntree, M_try = rf_mod$bestTune$mtry))}
      }
      else{nested_metrics_tuned <- NULL}
      
      ##### Export table ####
      final_results_RF <- bind_rows(Selt_full, Inner_full, Extern_full, nested_metrics_tuned)
    }
    
    #### BRT ####
    if(any(Model %in% "BRT")){
      #### Grid settlement ####
      brt_nested_results <- data.frame(R2 = numeric(), RMSE = numeric())
      
      if(Nested.CV == T | Inner.CV == T | Extern.CV == T | Self.CV == T){
        brt_model <- gbm.step(data = data, gbm.x = 1:(ncol(data)-1), gbm.y = ncol(data),  max.trees = max_trees, family = "gaussian", 
                              tree.complexity = tree_complexity, learing.rate = learning_rate, silent = T, 
                              bag.fraction = bag_fraction, verbose = F, tolerance.method = "fixed", tolerance = 0.1)}
      
      if(is.null(Manual.tuning.grid) == T){
        brt_grid <- expand.grid(
          n.trees = seq(100, 3000, by = 50),
          interaction.depth = seq(1, 10, by = 1), shrinkage = c(0.005, 0.01, 0.025, 0.05, 0.075, 0.1), n.minobsinnode = c(5, 10, 20))
      }
      else{brt_grid <- Manual.tuning.grid}
      
      brt_grid_fixed <- expand.grid(
        n.trees = brt_model$n.trees, interaction.depth = tree_complexity, 
        shrinkage = learning_rate, n.minobsinnode = min_obs)
      
      #### Self estimation (both caret et native) ####
      if(Self.CV == T){
        #### Native self stats #### 
        brt_pred_self <- predict(brt_model, data, n.trees = brt_model$n.trees)
        self_metrics_n <- data.frame(Method = "Self (natif)",
                                     BRT_R2 = signif(R2(brt_pred_self, data[[Param.clim]]), digits = 2),
                                     BRT_RMSE = signif(RMSE(brt_pred_self, data[[Param.clim]]), digits = 3))
        
        if(Return.param == T){self_metrics_n <- cbind(self_metrics_n, data.frame(BRT_ntree = brt_model$n.trees, Tree_complex = tree_complexity, Learn_rate = learning_rate))}
        
        #### Caret self stats #### 
        brt_self <- train(formula, data = data, method = "gbm", verbose = F, trControl = trainControl(method = "none"), bag.fraction = bag_fraction, tuneGrid = brt_grid_fixed)
        brt_pred_self <- predict(brt_self, data)
        
        self_metrics <- data.frame(Method = "Self (caret)",
                                   BRT_R2 = signif(R2(brt_pred_self, data[[Param.clim]]), digits = 2),
                                   BRT_RMSE = signif(RMSE(brt_pred_self, data[[Param.clim]]), digits = 3))
        
        if(Return.param == T){self_metrics <- cbind(self_metrics, data.frame(BRT_ntree = brt_model$n.trees, Tree_complex = tree_complexity, Learn_rate = learning_rate))}
        
        Selt_full <- rbind(self_metrics, self_metrics_n)
      }
      else{Selt_full <- NULL}
      
      #### Internal CV (OOB, intern k-fold) ####
      if(Inner.CV == T){
        Inner_full <- data.frame(
          Method = "Internal CV (OOB/ k-fold)",
          BRT_R2 = round(brt_model$cv.statistics$correlation.mean^2, digits = 2),
          BRT_RMSE = round(brt_model$cv.statistics$deviance.mean^0.5, digits = 2))
        
        if(Return.param == T){Inner_full <- cbind(Inner_full, data.frame(BRT_ntree = brt_model$n.trees, Tree_complex = tree_complexity, Learn_rate = learning_rate))}
      }
      else{Inner_full <- NULL}
      
      
      #### External CV (caret, k-fold) ####
      if(Extern.CV == T){
        if(Tuning.extern.CV == T){
          brt_grid_1 <- brt_grid
          if(Parallelize == T){
            n_cores <- parallel::detectCores() - 1
            cl <- makeCluster(n_cores)
            registerDoParallel(cl)}
        }
        else{brt_grid_1 <- brt_grid_fixed}
        
        set.seed(123)
        ctrl_inner <- trainControl(method = "cv", number = K.fold.inner)
        brt_cv <- train(formula, data = data, method = "gbm", verbose = F, trControl = ctrl_inner, bag.fraction = bag_fraction, tuneGrid = brt_grid_1)
        
        if(Parallelize == T & Tuning.extern.CV == T){stopCluster(cl); registerDoSEQ()}
        
        Extern_full <- data.frame(Method = "External CV (caret)",
                                  BRT_R2 = signif(brt_cv$results$Rsquared[which.min(brt_cv$results$RMSE)], digits = 2),
                                  BRT_RMSE = signif(brt_cv$results$RMSE[which.min(brt_cv$results$RMSE)], digits = 3))
        # BRT_R2 = brt_cv$results$Rsquared[which.min(brt_cv$results$RMSE)],
        # BRT_RMSE = brt_cv$results$RMSE[which.min(brt_cv$results$RMSE)])
        
        if(Return.param == T){
          Extern_full <- cbind(Extern_full, data.frame(BRT_ntree = brt_cv$finalModel$n.trees, Tree_complex = brt_cv$finalModel$interaction.depth, 
                                                       Learn_rate = brt_cv$finalModel$shrinkage, Min_obs = brt_cv$finalModel$n.minobsinnode))}
        
      }
      else{Extern_full <- NULL}
      
      #### Nested CV ####
      if(Nested.CV == T){
        #### Parallelize ####
        if(Parallelize == T){
          n_cores <- parallel::detectCores() - 1
          cl <- makeCluster(n_cores)
          registerDoParallel(cl)}
        
        #### Grid settings ####
        if(Tuning.nested.CV == T){brt_grid_2 <- brt_grid}
        else{brt_grid_2 <- brt_grid_fixed}
        
        #### Outer k-fold loop ####
        for (i in 1:K.fold.outer) {
          train_idx <- folds[[i]]
          train_data <- data[train_idx, ]
          test_data <- data[-train_idx, ]
          ctrl_inner <- trainControl(method = "cv", number = K.fold.inner)
          brt_mod <- train(formula, data = train_data, method = "gbm", tuneGrid = brt_grid_2, trControl = ctrl_inner, bag.fraction = bag_fraction, verbose = F)
          brt_pred <- predict(brt_mod, test_data)
          brt_nested_results <- rbind(brt_nested_results, data.frame(R2 = R2(brt_pred, test_data[[Param.clim]]), RMSE = RMSE(brt_pred, test_data[[Param.clim]])))
          if(Parallelize == T){stopCluster(cl); registerDoSEQ()}
        }
        
        #### Final summary table ####
        nested_metrics_tuned <- data.frame(Method = "Nested CV (Tuned)",
                                           BRT_R2 = round(mean(brt_nested_results$R2), digits = 2),
                                           BRT_RMSE = round(mean(brt_nested_results$RMSE), digits = 2))
        
        if(Return.param == T){
          nested_metrics_tuned <- cbind(nested_metrics_tuned, data.frame(BRT_ntree = brt_mod$bestTune$n.trees, Tree_complex = brt_mod$bestTune$interaction.depth, Learn_rate = brt_mod$bestTune$shrinkage))
        }
      }
      else{nested_metrics_tuned <- NULL}
      
      ##### Export table ####
      final_results_BRT <- bind_rows(Selt_full, Inner_full, Extern_full, nested_metrics_tuned)
    }
    
    
    
    ##### Export table ####
    if(any(Model %in% "BRT")){final_results <- final_results_BRT}
    if(any(Model %in% "RF")){final_results <- final_results_RF}
    if(any(Model %in% "BRT") & any(Model %in% "RF")){final_results <- full_join(final_results_RF, final_results_BRT, by = "Method")}
    
    if(is.null(Save.model) == F){return(list(brt_cv, final_results))}
    else{return(final_results)}
    
  }
  
  Merge.param <- list()
  List.model <- list()
  
  for(i in Param.clim){
    Res <- One_run(i)
    # return(Res)
    
    if(is.null(Save.model) == F){
      List.model[[length(List.model) + 1]] <- Res[[1]]
      Res <- Res[[2]]
    }
    
    Res$Param.clim <- i
    Merge.param[[length(Merge.param) + 1]] <- Res
  }
  
  #### Export ####
  Final.df <- dplyr::bind_rows(Merge.param)
  
  if(is.null(Save.model) == F){saveRDS(List.model, Save.model)}
  if(is.null(Save.table) == F){saveRDS(Final.df, Save.table)}
  
  
  tictoc::toc()
  print(Final.df)
  return(Final.df)
}

Diag.ternaire.methylation <- function(MGDGT, Mcol, My_colors, Show.Dearing, Show.Naafs.peat, Show.Plotly, Return.plot = F,
                                      Full.labels = T, Legend.pos = "right", Annot = NULL, Show.arrows = T, Lake.name = NULL,
                                      Show.lake = F, Add.facet = F, Show.soil = F, Show.peat = F, Remove.ACA = F, 
                                      Alpha.dot, Size.dot, Export.to.chart.studio = F, Save.path, W, H){
  #### Initialization values ####
  library(ggplot2)
  library(ggtern)            # permet de faire des graphiques ternaires
  if(missing(MGDGT)){warning("Import a matrix of GDGT")}
  if(missing(Show.Naafs.peat)){Show.Naafs.peat = F}
  if(missing(Show.Plotly)){Show.Plotly = F}
  if(missing(Show.Dearing)){Show.Dearing = F}
  if(missing(Save.path)){Save.path = NULL}
  if(missing(Alpha.dot)){Alpha.dot = 0.6}
  if(missing(Size.dot)){Size.dot = 2.5}
  if(missing(W)){W = NULL}
  if(missing(H)){H = NULL}
  if(missing(Mcol)){Mcol = NULL}
  if(missing(My_colors)){My_colors = NULL}
  
  #### Extract br-GDGT ####
  Cal.Mtern <- function(M){
    M <- M[,grep("^f.I", colnames(M))]
    III <- grep("III", names(M))
    III.II <- grep("II", names(M))
    I.II.III <- grep("I", names(M))
    II <- setdiff(III.II, III)  
    I <- setdiff(I.II.III, III.II)
    Mtern <- M[0]
    Mtern[["P.hexa"]] <- rowSums(M[,III])
    Mtern[["P.penta"]] <- rowSums(M[,II])
    Mtern[["P.tetra"]] <- rowSums(M[,I])
    Mtern <- data.frame(apply(Mtern, 2, function(x) x/rowSums(Mtern))) 
    return(Mtern)}
  Mtern <- Cal.Mtern(MGDGT)
  if(is.null(Mcol)==T){
    if(is.null(Lake.name) == T){Mtern[["Group"]] <- "Surface"}
    else{Mtern[["Group"]] <- Lake.name}}
  else{Mtern[["Group"]] <- Mcol}
  
  #### Color & shape settings ####
  Lab.list <- c(
    Lake_Ayrag = "grey30", Surface = "grey30", WZDB = "grey30", #Tuya = "grey30",
    Lakes = "royalblue", Lacustrine = "royalblue",
    'Lacustrine WDB' = "royalblue", "Soil WDB" = "darkorange", 
    "Fibrous soil" = "#bf812e", "K-warm/arid" = "darkorange", "K-cold/wet" = "royalblue", "K-lacustrine" = "#0073C2",
    "Topcore silk" = "#8c510a", 
    "1_Fresh" = "royalblue","2_Brakish" = "#e4af08","3_Salted" = "#8c510a",
    "1_Acid" = "royalblue","2_Neutral" = "#e4af08","3_Alkalin" = "#8c510a",
    "1_Hyper-arid" = "#8c510a","2_Arid" = "#bf812e", "3_Semi-arid" = "#dfc27e","4_Dry sub-humid" = "#f5e9bf", "5_Humid" = "#80cec1",
    "1. Hyper-arid" = "#8c510a","2. Arid" = "#bf812e", "3. Semi-arid" = "#dfc27e","4. Dry sub-humid" = "#f5e9bf", "5. Humid" = "#80cec1",
    "Dry-Cold" = "darkblue","Wet-Cold" = "darkblue","Dry-Warm" = "darkorange","Wet-Warm" = "darkorange", "Lake Raberg" = "royalblue",
    Soil = "darkorange", "Soil Dearing" = "darkorange", "Soil ACA" = "#c3510aff",
    Peat = "#74D43B", "peat Dearing" = "#74D43B", "Peat Naafs" = "#74D43B",
    Moss = "#74D43B", "Moss ACA" = "#1d5140ff",
    Azerbaijan = "darkorange", Mongolia = "royalblue", Chine = "red", Uzbekistan = "green",
    Tajikistan = "pink", Fazilman = "darkblue", Tuya = "grey30", Ogshagil = "#1d5140ff", Russia = "#74D43B",
    L1 = "#515a14ff", L2 =  "#abc837f6", L3 =  "#70ae77f6", L4 = "#e8a147ff", L5 = "#313695", L6 =  "#577AB7", L7 = "#b65928ff", L8 = "#7e332fff"
  )
  
  if(is.null(My_colors) == F){
    names(My_colors) <- unique(Mcol)
    Lab.list <- c(Lab.list, My_colors)}
  
  Shape.list <- c(
    Lakes = 16, Surface = 16, Lacustrine = 16,
    "Topcore silk" = 16, Soil = 4, "Soil ACA" = 16, "Fibrous soil" = 4, "Soil Dearing" = 4,
    "Dry-Cold" = 4, "Wet-Cold" = 19, # "Dry-Warm" = 4, "Wet-Warm" = 19,
    "Lacustrine WDB" = 4, "Soil WDB" = 4, WZDB = 2,
    "1_Hyper-arid" = 16,"2_Arid" = 16, "3_Semi-arid" = 16,"4_Dry sub-humid" = 16, "5_Humid" = 16,
    "1. Hyper-arid" = 16,"2. Arid" = 16, "3. Semi-arid" = 16,"4. Dry sub-humid" = 16, "5. Humid" = 16,
    "Lake Raberg" = 3, Peat = 3, "peat Dearing" = 3, "Peat Naafs" = 3, Moss = 3, "Moss ACA" = 16
  )
  
  if(is.null(Lake.name) == F){
    Shape.list <- c(Shape.list, New = 16)
    names(Shape.list)[length(Shape.list)] <- Lake.name}
  
  if(length(setdiff(unique(Mtern$Group), names(Shape.list))) > 0){
    Shape.list2 <- rep(19, length(unique(Mcol)))
    names(Shape.list2) <- unique(Mcol)
    Shape.list <- c(Shape.list, Shape.list2)
    Shape.list <- Shape.list[names(Shape.list)%in% unique(Mtern$Group)]
  }
  
  #### Labels settings ####
  if(Full.labels == T){My_labs <- labs(x = "Hexamethylated \n brGDGTs", y = "Pentamethylated \n brGDGTs", z = "Tetramethylated \n brGDGTs")}
  if(Full.labels == F){My_labs <- labs(x = "Hexa.", y = "Penta.", z = "Tetra.")}
  
  if(is.null(Annot) == F){My_annot <- labs(title = Annot)}
  else{My_annot <- NULL}
  
  if(Show.arrows == T){Arrows <- NULL}
  else{Arrows <- ggtern::theme_noarrows()}
  
  My_title <- element_text(hjust = 0, vjust = -6.5, face = "bold", size = 18)
  
  #### Plot ####
  if(Add.facet == F){
    p1 <- ggtern::ggtern(data = Mtern, aes(P.hexa, P.penta, P.tetra, color = Group, shape = Group)) +
      ggtern::theme_rgbw() +
      # theme_light()+
      My_annot +
      Arrows +
      theme(legend.key = element_blank(), legend.position = Legend.pos, plot.margin=unit(c(0,0,0,0),"cm"),
            plot.background = element_blank(), panel.background = element_blank(),
            # legend.box.spacing = unit(-5, "line"),
            legend.background = element_blank(), strip.background = element_blank(),
            plot.title = My_title,
            legend.key.height = unit(1, "line"))+
      geom_point(alpha = Alpha.dot, size = Size.dot, na.rm = T) +
      # geom_hex(aes(fill = Group))+
      # stat_density_tern(geom = 'polygon', n = 400, aes(fill  = ..level.., alpha = ..level..)) +
      scale_color_manual(name = "Samples type", values = Lab.list) +
      scale_shape_manual(name = "Samples type", values = Shape.list)+
      My_labs}
  
  #### Add facets ####
  if(Add.facet == T){
    p1 <- ggtern::ggtern(data = Mtern, aes(P.hexa, P.penta, P.tetra, color = Group, shape = Group)) +
      My_annot + 
      ggtern::theme_nogrid()+
      ggtern::theme_ticksinside()+
      ggtern::theme_nolabels()+ ggtern::theme_notitles()+
      theme(legend.key = element_blank(), legend.position = "none", plot.margin=unit(c(0,0,0,0),"cm"),
            plot.background = element_blank(), panel.background = element_blank(),
            legend.background = element_blank(), strip.background = element_blank(),
            plot.title = My_title, panel.grid = element_blank(),
            legend.key.height = unit(1, "line"))+
      geom_point(size = 0.1) +
      facet_wrap(vars(Group))+
      ggtern::stat_density_tern(geom = 'polygon', bins = 10, aes(fill = Group, alpha = ..level..), color = NA, linewidth = .005) +
      scale_color_manual(name = "Samples type", values = Lab.list) +
      scale_fill_manual(name = "Samples type", values = Lab.list) +
      My_labs
  }
  #### Save html ####
  if(Show.Plotly == T & is.null(Save.path) == F){
    library(plotly)
    library(htmlwidgets)
    print("Save Plotly.")
    m <- list(
      l = 150,
      r = 0,
      b = 0,
      t = 0,
      pad = 0
    )
    
    Save.plot.html <- gsub("pdf", "html", Save.path)
    Keep.name <- gsub(".*\\/", "", Save.plot.html)
    Path.root <- paste(gsub(Keep.name, "", Save.plot.html), "HTML_files/", sep = "")
    if(file.exists(Path.root) == F){dir.create(Path.root)}
    Save.plot.html <- paste(Path.root, Keep.name, sep = "")
    Mtern$label <- row.names(Mtern)
    
    axis <- function(title) {list(title = title,
                                  titlefont = list(size = 18),tickfont = list(size = 13),
                                  tickcolor = 'rgba(0,0,0,0)',ticklen = 5)}
    
    fig <- Mtern %>% plot_ly()
    fig <- fig %>% add_trace(type = 'scatterternary',mode = 'markers',
                             a = ~P.penta,b = ~P.hexa,c = ~P.tetra,
                             text = ~label,
                             color = ~Group, colors = Lab.list,
                             symbol = ~Group, symbols = Shape.list,
                             marker = list(size = 10, line = list('width' = 2)))
    
    fig <- fig %>% layout(
      # title = "Simple Ternary Plot with Markers",
      margin = m,
      ternary = list(sum = 100,
                     aaxis = axis('Pentamethylated brGDGTs'),
                     baxis = axis('Hexamethylated brGDGTs'),
                     caxis = axis('Tetramethylated brGDGTs')))
    
    saveWidget(fig, file = Save.plot.html)
    
    if(Export.to.chart.studio == T){
      Sys.setenv("plotly_username"="Lucas_Dugerdil")
      Sys.setenv("plotly_api_key"="fBxVNd3kb1T6msCwEJCL")
      Name.chartplot <- gsub("\\.html", "", Keep.name)
      api_create(fig, filename = Name.chartplot)
    }
  }
  
  if(Show.Plotly == T & is.null(Save.path) == T){print("**** You asked for Plotly but Save.path is missing. It is not possible to print in Plotly with Save.path. ****")}
  
  #### Save plots ####
  if(is.null(Save.path) == F){
    if(is.null(W) == F & is.null(H) == F){
      ggsave(Save.path, width = W*0.026458333, height = H*0.026458333, units = "cm")}
    else{ggsave(Save.path)}}
  
  detach("package:ggtern", unload=TRUE)
  
  if(Return.plot == T){return(p1)}
  else(return(Mtern))
}
